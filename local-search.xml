<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>杂谈 - A1</title>
    <link href="/2025/02/14/A1/"/>
    <url>/2025/02/14/A1/</url>
    
    <content type="html"><![CDATA[<p>步进A1</p><span id="more"></span><h2 id="春-2025"><a href="#春-2025" class="headerlink" title="春@2025"></a>春@2025</h2><p>春天总是令人舒适呢……</p><p>上次感受到这样的春天已经是2023年了。</p><p>当时总是想到一些美好的东西，又和现实的做题生活形成鲜明对比了，这不好。</p><p>这里是几座玻璃高楼 下面是个平台</p><p>对了，这里有一棵樱花树</p><p>对了，我是14岁的女孩子吗？</p><p>这里的风好清澈，推着山上的风力发电机，为我们提供不竭的电力</p><p>哦对，这里是学校，我们设计的环形工程</p><p>周围全是粉色的树，我们忘记了是什么。楼顶有被称为高架桥的宽栈道吧，整体形成了弧形，我不知道是为什么设计，不过上面景色很美</p><p>不过不要从实用角度考虑了。</p><p>很宁静的去处。</p><p>我不是猫猫，我旁边的女孩子是猫猫，我们沉醉在这里了，不要回去上课</p><p>您问这台机器？</p><p>这是22版幻14呐～ 6900HS+6800S</p><p>这是什么时候的梦呢？</p><p>「汩余若将不及兮，恐年岁之不吾与。」我再也不能做这种梦了。我已经算是高龄了。</p><p>后来我急急急，我厌恶做题，我要复现它。用文字无法表达那种美好。<br><del>这是恐春症的由来，当然现在已经治好了</del></p><p>若是又想起什么，我还回来补上的</p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>我发现我现在很难有有营养的内容产出了。</p><p>有的东西我在实操时候有学习到，但是忘记或者懒得写blog，后来就完全忘记了是什么事</p><p>再加上现在的学业压力，更难去更新了</p><p>但是本来这只是作为blog使用的站，而且挂在github pages上，不用我花钱，所以无论怎样它将一直存在的。</p><h2 id="开服"><a href="#开服" class="headerlink" title="开服"></a>开服</h2><p>我刚有一篇RLCraft开服记录，原因都在里面写好了。</p><p>这个寒假，我一直在和朋友们探索mc服务器</p><p>用作服务器的机器是3700x 32G内存。</p><p>一开始，我开了服务器供涩图群群友玩，但是现在也不怎么活跃了</p><p>然后我又在这台机器上开了一个1.20.6的服务器，给我高中同学玩</p><p>结果他们网瘾少年，每天16h以上在线</p><p>我做转发用的aliyun ecs，网费太贵了，像 <del>抢钱一样</del></p><p>平均每天都要干掉差不多十块钱，这太贵了</p><p>所以换到了sakura frp，因为都是共享节点，所以我只写了供高中同学玩的端口的转发</p><p>涩图群服也莫名其妙就关掉了。</p><p>结果几天前，sakura frp突然更换域名，我的frpc config失效了，然而我同时也转发了ssh，所以我在家连不上宿舍里的服务器了</p><p>直到今天回到学校，局域网内ssh过去才改好</p><p>然后又配了SRV记录，给涩图群服拉起来，又往两个群里发了“服务器复活了！！”</p><h2 id="离散数学"><a href="#离散数学" class="headerlink" title="离散数学"></a>离散数学</h2><p>我不知道定义，也没有查过</p><p>只不过看一边叫离散数学一边叫离散结构</p><p>只看了MIT的网课，有proof以及真值表什么的，这应该是第一部分</p><p>后面我看有图有树的</p><p>MIT的课后面还要教什么算法，迷</p><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>也是这一学期要学的</p><p>我不知道是什么契机，反正我在20年时候学过一阵子</p><p>当时我在用openSUSE Leap， <del>精德</del></p><p>咏唱的public static void main(String[] args)我还记得</p><p>忘了当时什么精神状态，在konsole里面使用宋体，逆天</p><h2 id="2021"><a href="#2021" class="headerlink" title="2021(?)"></a>2021(?)</h2><p>2021左右</p><p>当时还在上初中，闲暇时期使用arch，在用一个3200U的本子</p><p>有时候听着Recondite的Waldluft，还有Black Russian这种有清晨氛围的Techno，用那个残破的Linux网易云（当时还不算残破）</p><p>用1080p的低分屏，网易云不能hidpi的问题还没发现</p><p>喜欢在周末下雨的清晨，折腾gentoo</p><p>“给我来一杯Java！”</p><p>开源世界是永恒的，Linux是永恒的，Ruby是永恒的，Java是永恒的，……</p><p>所以我当年积极进行各种软件考古，FreeDOS，BSD，以及CentOS 6……</p><p>然而到现在，我再也没有了当时的激情，开始遥遥落后</p>]]></content>
    
    
    
    <tags>
      
      <tag>Talk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Arch Linux 安装教程</title>
    <link href="/2025/01/19/archlinux-installation/"/>
    <url>/2025/01/19/archlinux-installation/</url>
    
    <content type="html"><![CDATA[<p><strong>此文章适用于现代（2010年及以后）的x86_64机器</strong></p><span id="more"></span><p>截至教程发布日，Arch Linux Live CD的最新版本是2025年1月的，测试无误。</p><h2 id="支持的硬件"><a href="#支持的硬件" class="headerlink" title="支持的硬件"></a>支持的硬件</h2><p><strong>·x86_64架构的CPU，建议为2008年以后的CPU，比如 Intel Core i系列之后的以及AMD FX<br>·至少有1GB内存（Arch Wiki上写的最小的512MB现在已经无法启动如今的Live CD）<br>·可用的网络连接<br>·20GB可用的硬盘空间</strong></p><h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><h3 id="制作安装介质"><a href="#制作安装介质" class="headerlink" title="制作安装介质"></a>制作安装介质</h3><ol><li>到镜像站去下载最新的Arch Linux Live CD iso -&gt;<br><code>https://mirrors.ustc.edu.cn/archlinux/iso/latest/archlinux-x86_64.iso</code></li><li>使用工具将其写入到USB驱动器或者刻录光盘（不建议）<br> 推荐写入工具<a href="https://mirrors.bfsu.edu.cn/github-release/balena-io/etcher/LatestRelease/">balenaEtcher</a></li><li>重启后按主板厂商的指引设置USB启动或选择USB启动（若失败请先关闭安全启动[^1]）</li><li>从USB驱动器引导后就进入了Live CD环境</li></ol><div class="note note-info">            <p>如果这一步循环重启，并且Systemd log输出往往是到和网络相关的部分卡住<br>关机，然后拔掉电源线，等待十秒以上再插电开机</p>          </div><h4 id="定义环境变量（可选）"><a href="#定义环境变量（可选）" class="headerlink" title="定义环境变量（可选）"></a>定义环境变量（可选）</h4><p>很多命令都需要更改为你自己的设置。<br>因此为了方便（可以直接复制我的），我们在此处先定义一些环境变量。</p><p>这些环境变量的定义需要你在等号<code>=</code>后面输入要输入的信息。</p><p>首先，是你要连接的 WIFI 名字，也就是 SSID：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> SSID=<br></code></pre></td></tr></table></figure><p>然后是它的密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> WIFI_PASSWORD=<br></code></pre></td></tr></table></figure><p>新建的用户名字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> NEW_USERNAME=<br></code></pre></td></tr></table></figure><h3 id="Live-CD设置"><a href="#Live-CD设置" class="headerlink" title="Live CD设置"></a>Live CD设置</h3><ol><li>连接网络 -&gt;<br> <strong>WIFI:</strong> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">iwctl station wlan0 scan<br>iwctl station wlan0 get-networks<br>iwctl station wlan0 connect <span class="hljs-variable">$SSID</span> --passphrase <span class="hljs-variable">$WIFI_PASSWORD</span> <span class="hljs-comment">#$SSID代表WIFI的名字，$PASSWORD代表密码</span><br>ip addr<br></code></pre></td></tr></table></figure> <strong>如果直接插网线的话上面的步骤可以跳过</strong> <div class="note note-info">            <p>如果没有<code>wlan0</code>的话，可能是没有无线网卡或者是没有驱动，请插网线。如果没有RJ45网口，请更换无线网卡至AX210（<br>对于另一种情况（通常和上面提到的循环重启绑定），参见下面的内容<br>若<code>ip addr</code>返回了wlan0的信息并且下面有正确的ip，则代表网络已连接成功。</p>          </div> <div class="note note-warning">            <p>遇到循环重启的情况下，通常正常开机之后无线网卡被block了，需要手动unblock</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rfkill unblock all<br></code></pre></td></tr></table></figure><p>之后和正常的操作方式并无差异</p>          </div> 可选：停止<code>reflector</code>服务，防止<code>/etc/pacman.d/mirrorlist</code>被写入其他地区镜像 -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl stop reflector.service<br></code></pre></td></tr></table></figure></li><li>配置镜像<br> 国内网络环境懂得都懂，用镜像（注意：这一步须在<code>reflector.service</code>停止后进行，可手动结束或等待其执行完成，否则编辑完的<code>mirrorlist</code>会被它重写） -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/pacman.d/mirrorlist<br></code></pre></td></tr></table></figure><ul><li>在文件开头按<code>i</code>进入<code>insert</code>模式，添加<code>Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch</code></li><li>按<code>esc</code>退出<code>insert</code>模式，输入<code>:wq</code>保存并退出<code>vim</code></li></ul></li><li>（可选）ssh 远程连接<br> 远程访问，可以直接复制命令。 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ip a<br></code></pre></td></tr></table></figure> 看 wlan0（如果是 WIFI 连接）下面的信息，这里会显示联网后本机在局域网内被分配的ip地址。记下它。<br> 然后我们设置这台机器 root 用户的密码： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">passwd<br></code></pre></td></tr></table></figure> 这里随便设一个，只要你能记住。<br> 我这里假设这台机器的ip是 192.168.101.12，于是在另一台在同一个局域网的机器上，执行 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh root@192.168.101.12<br></code></pre></td></tr></table></figure> 然后按提示，输入<code>yes</code>，再输入刚才设置的密码，就可以连接了。</li></ol><h3 id="磁盘相关"><a href="#磁盘相关" class="headerlink" title="磁盘相关"></a>磁盘相关</h3><ol><li>磁盘分区 -&gt; <div class="note note-warning">            <p>这一步需要按照情况自行更改，操作不当会导致数据丢失。一定要理解下面info中的内容。</p>          </div> <div class="note note-info">            <p>我这台机器有一个NVME接口的固态硬盘，它的编号是<code>nvme0n1</code>。在有多个NVME接口的主板上，如果你插了多块硬盘，它将会有<code>nvme1n1</code>、<code>nvme2n1</code>等编号，一定要清楚自己要操作的是哪块硬盘。连在SATA与USB接口上的硬盘会显示<code>sda</code>、<code>sdb</code>等，<code>sda</code>可能是U盘也可能是内置硬盘，请先<code>lsblk</code>进行辨认。这条命令的意义是对<code>nvme0n1</code>进行操作，请根据自身需要更改。</p>          </div> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cfdisk /dev/nvme0n1<br></code></pre></td></tr></table></figure> <div class="note note-warning">            <p>如果先前有Windows安装的话，请注意不要把Windows分区直接缩小大小，会让Windows坏掉。应先使用其他工具完成分区大小调整再进行后续步骤。</p>          </div><ul><li>使用GPT分区表（这是UEFI引导的必须条件）</li><li>推荐分区方案 -&gt;<ul><li>EFI分区：不小于4MB，类型：<code>EFI System</code></li><li>主分区：不小于10GB，类型：<code>Linux filesystem</code><br>  （建议在分区内部建立一个swapfile来承担swap的任务）<br>  <img src="/../img/archlinux-installation/1.png"></li></ul></li><li>结束后，选<code>Write</code>再输入<code>yes</code>来写入分区表，再选<code>Quit</code>退出</li></ul></li><li>建立文件系统 -&gt;<br> 主分区使用<code>ext4</code>文件系统 <div class="note note-warning">            <p>如果先前安装了Windows或者其他操作系统，不要执行第一条，会导致Windows引导损坏。</p>          </div> <div class="note note-info">            <p>这条命令也需要自行修改，意为在<code>nvme0n1</code>的第一分区创建<code>vfat</code>文件系统，在<code>nvme0n1</code>的第二分区创建<code>ext4</code>文件系统。</p>          </div> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkfs.vfat /dev/nvme0n1p1<br>mkfs.ext4 /dev/nvme0n1p2<br></code></pre></td></tr></table></figure> <div class="note note-info">            <p>如果之前<code>nvme0n1p2</code>建立过其他文件系统，这里需要按<code>y</code>确认。</p>          </div></li><li>挂载分区 -&gt; <div class="note note-info">            <p>改，勿照抄。<code>/</code>的<code>nvme0n1p2</code>挂载到<code>/mnt</code>，再把<code>nvme0n1p1</code>这个EFI分区挂到<code>/mnt/boot/efi</code>下。</p>          </div> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">mount /dev/nvme0n1p2 /mnt<br><span class="hljs-built_in">mkdir</span> -p /mnt/boot/efi<br>mount /dev/nvme0n1p1 /mnt/boot/efi<br></code></pre></td></tr></table></figure></li><li>创建<code>swapfile</code> -&gt; <div class="note note-info">            <p><code>swap</code>的用途是在内存不足时，将硬盘的一部分作为内存的扩展空间使用。这里<code>swap</code>创建为8G，可根据需要改变<code>count=</code>后的数字，单位是MB。当然如果内存够大也可以不用执行这些命令。</p>          </div> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=/mnt/swapfile bs=1M count=8192<br><span class="hljs-built_in">chmod</span> 600 /mnt/swapfile<br>mkswap /mnt/swapfile<br>swapon /mnt/swapfile<br></code></pre></td></tr></table></figure></li></ol><h3 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h3><ol><li>安装软件包 -&gt;<br> <strong>首先初始化keyring！！</strong> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman -Sy archlinux-keyring<br></code></pre></td></tr></table></figure><h4 id="使用KDE-Plasma作桌面环境的系统"><a href="#使用KDE-Plasma作桌面环境的系统" class="headerlink" title="使用KDE Plasma作桌面环境的系统"></a><strong>使用KDE Plasma作桌面环境的系统</strong></h4> <code>pacstrap</code>安装必要的包 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacstrap /mnt base linux-zen linux-firmware linux-zen-headers base-devel git zsh zsh-completions grub efibootmgr networkmanager openssh vim plasma konsole dolphin noto-fonts-cjk noto-fonts noto-fonts-emoji noto-fonts-extra fcitx5-chinese-addons fcitx5-gtk chromium fastfetch btop<br></code></pre></td></tr></table></figure><h4 id="使用GNOME作桌面环境的系统"><a href="#使用GNOME作桌面环境的系统" class="headerlink" title="使用GNOME作桌面环境的系统"></a><strong>使用GNOME作桌面环境的系统</strong></h4> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacstrap /mnt base linux-zen linux-firmware linux-zen-headers base-devel git zsh zsh-completions grub efibootmgr networkmanager openssh vim gnome noto-fonts-cjk noto-fonts-emoji noto-fonts-extra ibus ibus-libpinyin chromium fastfetch btop<br></code></pre></td></tr></table></figure><h4 id="使用命令行界面的系统-Headless"><a href="#使用命令行界面的系统-Headless" class="headerlink" title="使用命令行界面的系统(Headless)"></a><strong>使用命令行界面的系统(Headless)</strong></h4> 这是我的习惯 -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacstrap /mnt base linux-zen linux-firmware linux-zen-headers base-devel git zsh zsh-completions grub efibootmgr networkmanager openssh vim fastfetch btop tmux<br></code></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4></li><li>生成<code>fstab</code> -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab<br></code></pre></td></tr></table></figure></li><li><code>chroot</code>到新系统 -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">arch-chroot /mnt<br></code></pre></td></tr></table></figure></li></ol><h3 id="初步配置系统"><a href="#初步配置系统" class="headerlink" title="初步配置系统"></a>初步配置系统</h3><ol><li>时间设置 -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<br>hwclock --systohc<br></code></pre></td></tr></table></figure></li><li>用户设置 -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> archlinux &gt; /etc/hostname<br>useradd -m <span class="hljs-variable">$NEW_USERNAME</span> -G wheel<br>passwd <span class="hljs-variable">$NEW_USERNAME</span><br></code></pre></td></tr></table></figure> <div class="note note-info">            <p><code>useradd</code>用于添加账户，<code>passwd</code>用于修改密码，为安全考虑输入的密码不会直接显示出来。虽然没有反应，但确实是输入进去了。<br><code>-m</code>参数用以添加用户目录，<code>-G</code>参数用以将用户加入到<code>wheel</code>组中。这个组将会被赋予使用<code>sudo</code>的权力。</p>          </div></li><li>编辑<code>sudoers</code> -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">visudo<br></code></pre></td></tr></table></figure> 将文件中的<code># %wheel ALL=(ALL:ALL) ALL</code>（大概率在第125行，使用<code>vim</code>按<code>:125</code>跳转）的注释取消，使得<code>wheel</code>组里的用户可以使用<code>sudo</code></li><li>配置<code>zsh</code> -&gt; <div class="note note-info">            <p>zsh 是一个有强大客制化能力的 shell，并且 Apple 也将新 macOS 默认的 shell 换成了 zsh。现在Arch Linux Live CD 的默认 shell 就是 zsh。<br>如果不喜欢zsh，或者考虑兼容性，请跳过这一步。</p>          </div> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S grml-zsh-config<br></code></pre></td></tr></table></figure></li><li>本地化 -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;LANG=\&quot;en_US.UTF-8\&quot;&quot;</span> &gt;&gt; /etc/locale.conf<br>sed -i <span class="hljs-string">&quot;s@#zh_CN.UTF-8 UTF-8@zh_CN.UTF-8 UTF-8@g&quot;</span> /etc/locale.gen<br>sed -i <span class="hljs-string">&quot;s@#en_US.UTF-8 UTF-8@en_US.UTF-8 UTF-8@g&quot;</span> /etc/locale.gen<br></code></pre></td></tr></table></figure> 此处命令意为去掉<code>#zh_CN.UTF-8 UTF-8</code>和<code>#en_US.UTF-8 UTF-8</code>的注释符号“<code>#</code>”<br> 最后运行 -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">locale-gen<br></code></pre></td></tr></table></figure></li><li>服务设置 -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl <span class="hljs-built_in">enable</span> NetworkManager<br>systemctl <span class="hljs-built_in">enable</span> sshd<br>systemctl <span class="hljs-built_in">enable</span> sddm <span class="hljs-comment"># KDE</span><br>systemctl <span class="hljs-built_in">enable</span> gdm <span class="hljs-comment"># GNOME</span><br></code></pre></td></tr></table></figure></li><li>引导设置 -&gt;<br> <code>gurb</code>已支持引导Windows。<br> 可以让<code>grub</code>找到Windows。 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -Sy ntfs-3g os-prober<br></code></pre></td></tr></table></figure> 对于<code>UEFI</code>引导的安装方式<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">grub-install --target=x86_64-efi --efi-directory=/boot/efi<br>sed -i <span class="hljs-string">&quot;s@#GRUB_DISABLE_OS_PROBER=false@GRUB_DISABLE_OS_PROBER=false@g&quot;</span> /etc/default/grub<br>grub-mkconfig -o /boot/grub/grub.cfg<br></code></pre></td></tr></table></figure><br> 对于<code>BIOS</code>引导的安装方式<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">grub-install /dev/nvme0n1<br>sed -i <span class="hljs-string">&quot;s@#GRUB_DISABLE_OS_PROBER=false@GRUB_DISABLE_OS_PROBER=false@g&quot;</span> /etc/default/grub<br>grub-mkconfig -o /boot/grub/grub.cfg<br></code></pre></td></tr></table></figure></li><li>退出<code>chroot</code>环境并重启 -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">exit</span><br>reboot<br></code></pre></td></tr></table></figure><strong>至此Arch Linux的安装就完成了</strong><br><strong>接下来是配置部分</strong></li></ol><h3 id="进一步配置系统"><a href="#进一步配置系统" class="headerlink" title="进一步配置系统"></a>进一步配置系统</h3><p><strong>如果是KDE的话</strong>，重启系统后，大概就是这样的 -&gt;<br><img src="/../img/archlinux-installation/2.png"></p><ol><li>输入法配置<br> 如果直接<code>右键</code>-<code>配置</code>是会显示这个的 -&gt;<br> <img src="/../img/archlinux-installation/3.png"><br> 这会进入文本配置，显然我们是不懂的（<br> 所以要安装<code>fcitx5-configtool</code> -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S fcitx5-configtool<br></code></pre></td></tr></table></figure> 然后再<code>右键</code>-<code>配置</code>就可以看到 -&gt;<br> <img src="/../img/archlinux-installation/4.png"><br> 然而现在按<code>Ctrl+Tab</code>是不能切换到拼音输入法的，我们需要把<code>Fcitx5</code>设为默认输入法并自动启动 -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vim /etc/environment<br></code></pre></td></tr></table></figure> 把下面的东西加进去 -&gt; <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">GTK_IM_MODULE=fcitx<br>QT_IM_MODULE=fcitx<br>XMODIFIERS=@im=fcitx<br>SDL_IM_MODULE=fcitx<br>GLFW_IM_MODULE=ibus<br></code></pre></td></tr></table></figure> 重新登录就可以正常使用了<br> 更多用法请参阅<a href="https://wiki.archlinux.org/title/Fcitx5_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Arch Wiki</a></li><li>软件源<br> 众所周知，官方源对于灰色地带&#x2F;非自由软件是不收录的。<br> 所以我们通常用第三方源+<code>AUR</code>来进行补充。<br> 官方源是不带任何<code>AUR</code>工具的，所以我们先装<code>archlinuxcn</code>源 -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vim /etc/pacman.conf<br></code></pre></td></tr></table></figure> 加入以下文本 -&gt; <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">[archlinuxcn]<br>Server = https://mirrors.bfsu.edu.cn/archlinuxcn/$arch<br></code></pre></td></tr></table></figure> 然后获取<code>keyring</code> -&gt; <div class="note note-warning">            <p>（2024.9.7测试问题已解决，此部分的内容已过时，仅在后续出现类似问题时供参考用）<br>近期这一步会出现问题，因为archlinuxcn 社区源的 keyring 包 archlinuxcn-keyring 由 farseerfc 的 key 签署验证，而 Arch Linux 官方 keyring 中包含了 farseerfc 的 key 。自12月初 archlinux-keyring 中删除了一个退任的 master key (<a href="https://gitlab.archlinux.org/archlinux/archlinux-keyring/-/issues/246">https://gitlab.archlinux.org/archlinux/archlinux-keyring/-/issues/246</a>) 导致 farseerfc 的 key 的信任数不足，由 GnuPG 的 web of trust 推算为 marginal trust，从而不再能自动信任 archlinuxcn-keyring 包的签名。(转自Arch Linux CN Telegram Messages Channel)</p>          </div> 如果你在新系统中尝试安装<code>archlinuxcn-keyring</code>包时遇到如下报错： <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">error: archlinuxcn-keyring: Signature from &quot;Jiachen YANG (Arch Linux Packager Signing Key) &lt;farseerfc@archlinux.org&gt;&quot; is marginal trust<br></code></pre></td></tr></table></figure> 请使用以下命令在本地信任 farseerfc 的 key 。此 key 已随<code>archlinux-keyring</code>安装在系统中，只是缺乏信任： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman-key --lsign-key &quot;farseerfc@archlinux.org&quot;<br></code></pre></td></tr></table></figure> 然后 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -Sy archlinuxcn-keyring<br></code></pre></td></tr></table></figure> 就可以使用<code>archlinuxcn</code>源了！<br> 由于要使用<code>AUR</code>，所以我们先装一个AUR工具： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S paru<br></code></pre></td></tr></table></figure> 详细的用法和<code>pacman</code>一样。</li><li>引导Windows<br> 在安装系统时，<code>os-prober</code>往往不能正常检测到Windows，需要我们再运行 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo grub-mkconfig -o /boot/grub/grub.cfg<br></code></pre></td></tr></table></figure> 重启即可看到<code>Windows Boot Manager</code>。</li></ol><h2 id="显卡驱动"><a href="#显卡驱动" class="headerlink" title="显卡驱动"></a>显卡驱动</h2><p>如果是A卡和I卡，开源的驱动会做得很好</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S xf86-video-amdgpu <span class="hljs-comment"># AMD</span><br>sudo pacman -S xf86-video-intel <span class="hljs-comment"># Intel</span><br></code></pre></td></tr></table></figure><p>对于部分老显卡，可能不适用，需要移步 Arch Wiki 中相关部分<br><a href="https://wiki.archlinux.org/title/Xorg#Driver_installation">https://wiki.archlinux.org/title/Xorg#Driver_installation</a></p><p>而N卡，需要进行以下步骤</p><h3 id="查看显卡型号"><a href="#查看显卡型号" class="headerlink" title="查看显卡型号"></a>查看显卡型号</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">lspci -k | grep -A 2 -E <span class="hljs-string">&quot;(VGA|3D)&quot;</span><br></code></pre></td></tr></table></figure><p>GeForce 900 系以及更新的显卡（NV110+），安装 nvidia（用于官方源里的标准内核）或者 nvidia-lts（用于 linux-lts 内核）</p><p>Turing (NV160&#x2F;TUXXX) 系列或更新的显卡。可以安装 nvidia-open 包，开源的（仅适用于官方源里的内核，其他内核上必须使用 nvidia-open-dkms 包）</p><p>更老的显卡型号（发布于 2010 年或更早），就用内核自带的 Nouveau</p><h3 id="安装驱动"><a href="#安装驱动" class="headerlink" title="安装驱动"></a>安装驱动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S nvidia-open-dkms nvidia-settings<br></code></pre></td></tr></table></figure><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>安装 NVIDIA 官方的驱动之后，需要编辑<code>/etc/mkinitcpio.conf</code>，在 HOOKS 一行删除<code>kms</code>并保存</p><p>然后执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkinitcpio -P<br></code></pre></td></tr></table></figure><p>重新生成一次镜像。这能防止 initramfs 包含 nouveau 模块，避免 nouveau 和官方驱动的冲突。</p><h3 id="笔记本双显卡配置"><a href="#笔记本双显卡配置" class="headerlink" title="笔记本双显卡配置"></a>笔记本双显卡配置</h3><p>因为笔记本经常遇到需要睡眠&#x2F;唤醒的情况，故不建议在使用Linux时开启独显直连</p><p>建议使用Intel&#x2F;AMD的核显，安装适用的驱动，还有渲染分载需要的NVIDIA PRIME</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S xf86-video-amdgpu <span class="hljs-comment"># AMD</span><br>sudo pacman -S xf86-video-intel <span class="hljs-comment"># Intel</span><br>sudo pacman -S nvidia-prime<br></code></pre></td></tr></table></figure><p>之后就可以愉快的使用 Wayland 作为显示协议</p><p>在需要使用 NVIDIA GPU 的时候（如游戏），使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">prime-run xxx <span class="hljs-comment"># xxx为命令</span><br></code></pre></td></tr></table></figure><h2 id="常用软件"><a href="#常用软件" class="headerlink" title="常用软件"></a>常用软件</h2><ol><li>telegram</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S telegram-desktop<br></code></pre></td></tr></table></figure><ol start="2"><li>Visual Studio Code（Official version）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">paru -S visual-studio-code-bin<br></code></pre></td></tr></table></figure><ol start="3"><li>Wine<br>先启动 <code>/etc/pacman.conf</code> 中的 <code>multilib</code> 源，其中包含32位软件<br>不要直接复制这些命令，要先看好你的显卡是哪家的</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S lib32-mesa <span class="hljs-comment"># 普通御三家卡</span><br>sudo pacman -S lib32-nvidia-utils <span class="hljs-comment"># 绿厂闭源驱动，效果好，需要现代N卡</span><br>sudo pacman -S lib32-amdgpu-pro-oglp <span class="hljs-comment"># 专业A卡</span><br>sudo pacman -S wine wine-gecko wine-mono lib32-alsa-lib lib32-alsa-plugins<br></code></pre></td></tr></table></figure><ol start="4"><li>Chrome &#x2F; Edge</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">paru -S microsoft-edge-stable-bin <span class="hljs-comment"># 莫名慢速下载警告</span><br>paru -S google-chrome<br></code></pre></td></tr></table></figure><ol start="5"><li>网易云音乐<br>因为原版好像似了一半，所以使用替代版<br>Go 写的 musicfox，TUI 版网易云</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">paru -S go-musicfox-git<br></code></pre></td></tr></table></figure><p>原版:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">paru -S netease-cloud-music<br></code></pre></td></tr></table></figure><ol start="6"><li>Steam</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S steam<br>paru -S proton<br></code></pre></td></tr></table></figure><ol start="7"><li>Clash Verge Reversion<br>这是一个 Clash Verge 的修复版本，解决了原版无法更新订阅的问题</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">paru -S clash-verge-rev<br></code></pre></td></tr></table></figure><h2 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h2><h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><p>对于 zsh, 我推荐 Powerlevel10k。<br>它的 Github 仓库链接是<code>https://github.com/romkatv/powerlevel10k</code><br>当你添加了 archlinuxcn 源之后，你可以</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S zsh-theme-powerlevel10k-git<br></code></pre></td></tr></table></figure><p>创建<code>~/.zshrc</code>并加入<code>source /usr/share/zsh-theme-powerlevel10k/powerlevel10k.zsh-theme</code><br>在这里如果你直接运行<code>source ~/.zshrc</code>，你会发现这里有很多图标不能显示。<br>所以要安装「高级」的字体，也就是打了补丁的 Nerd Fonts。这是一个系列，加入了很多图标。<br>我喜欢 Meslo Font，你也可以换成别的，比如 <code>ttf-jetbrains-mono-nerd</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">paru -S ttf-meslo-nerd<br></code></pre></td></tr></table></figure><p>重启Konsole, 然后新建配置文件，更改字体，<br>然后<code>source ~/.zshrc</code>并运行<code>p10k configure</code>就可。</p><h3 id="字体配置"><a href="#字体配置" class="headerlink" title="字体配置"></a>字体配置</h3><p>一天你打开浏览器，看到了抽象的日本字体，比如<span lang="ja">关</span>、<span lang="ja">复</span>的字形过窄，<span lang="ja">门</span>的点变成了竖插在上面……<br>这是不可接受的。<br>于是你执行<code>vim ~/.fonts.conf</code><br>把以下内容写了进去：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">fontconfig</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;fonts.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">fontconfig</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">alias</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>sans-serif<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">prefer</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Noto Sans CJK SC<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Noto Sans CJK TC<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Noto Sans CJK JP<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">prefer</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">alias</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">alias</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>monospace<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">prefer</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Noto Sans Mono CJK SC<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Noto Sans Mono CJK TC<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Noto Sans Mono CJK JP<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">prefer</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">alias</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">fontconfig</span>&gt;</span><br></code></pre></td></tr></table></figure><p>并<code>fc-cache -fv</code><br>问题就聪明的解决了。</p><h3 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h3><p>Vim 是一个文本编辑器，我们已经安装好了。<br>它有强大的客制化能力，你甚至可以把它变成IDE。<br>比如<code>https://github.com/amix/vimrc</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> --depth=1 https://github.com/amix/vimrc.git ~/.vim_runtime<br>sh ~/.vim_runtime/install_awesome_vimrc.sh<br></code></pre></td></tr></table></figure><p>如果网络条件差也是没有办法（（<br>请注意一下「常用软件」部分的第7号，这是一个奇妙小工具。</p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录 RLCraft 服务器的安装</title>
    <link href="/2025/01/18/rlcraft-installation/"/>
    <url>/2025/01/18/rlcraft-installation/</url>
    
    <content type="html"><![CDATA[<p>最近厌倦了原版生存，于是切换到RLCraft</p><span id="more"></span><h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><p>这两个下载好预备着，因为后续不大可能有大更新，所以是直链</p><a class="btn" href="https://www.curseforge.com/minecraft/modpacks/rlcraft/files/4612990"  target="_blank">RLCraft Server Pack</a><a class="btn" href="https://maven.minecraftforge.net/net/minecraftforge/forge/1.12.2-14.23.5.2860/forge-1.12.2-14.23.5.2860-installer.jar"  target="_blank">Forge 1.12.2 直链</a><p>然后，因为1.21.2是一个古老的版本，不能使用比较新的JRE（经测试17已经不能成功启动，未测试11）</p><p>所以我们只得使用 Java 8，相信JAVA_HOME的切换对于本站的读者已经不是难事。</p><p>对于Arch Linux，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S jre8-openjdk<br>sudo archlinux-java <span class="hljs-built_in">set</span> java-8-openjdk/jre<br></code></pre></td></tr></table></figure><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>我们新建一个文件夹作为服务器的root directory，在这里我将其命名为<code>rlcraft</code></p><p>之后将Forge installer和RLCraft压缩包放入其中，再解压RLCraft的压缩包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">❯ <span class="hljs-built_in">ls</span><br> config                                                   optionsof.txt  <span class="hljs-string">&#x27;RLCraft Server Pack 1.12.2 - Release v2.9.3.zip&#x27;</span>   scripts<br> forge-1.12.2-14.23.5.2860-installer.jar                  options.txt    <span class="hljs-string">&#x27;RLCraft v2.9.1c Changelog.txt&#x27;</span>                     server.properties<br><span class="hljs-string">&#x27;FOR SERVERS ONLY - SET THESE IN SERVER.PROPERTIES.txt&#x27;</span>   resourcepacks  <span class="hljs-string">&#x27;RLCraft v2.9.3 + v2.9.2d Changelog.txt&#x27;</span>            structures<br> mods                                                     resources      <span class="hljs-string">&#x27;RLCraft v2.9 Changelog.txt&#x27;</span><br><br></code></pre></td></tr></table></figure><p>安装Forge</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -jar forge-1.12.2-14.23.5.2860-installer.jar --installServer<br></code></pre></td></tr></table></figure><p>因为大陆的网络可能不好，所以Headless服务器推荐V2rayA，archcn源已收录</p><h1 id="启动！"><a href="#启动！" class="headerlink" title="启动！"></a>启动！</h1><p>相信本站的读者都已经有过开原版服的经历了，对后续的内容一定轻车熟路</p><p>修改server.properties和eula.txt</p><p><code>java -jar forge-1.12.2-14.23.5.2860.jar nogui</code></p><p><del>享受游戏即可</del>不好玩，不要玩，关了</p>]]></content>
    
    
    
    <tags>
      
      <tag>Minecraft</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂谈 - A0</title>
    <link href="/2025/01/15/A0/"/>
    <url>/2025/01/15/A0/</url>
    
    <content type="html"><![CDATA[<p>步进A0</p><span id="more"></span><h2 id="近期blog问题"><a href="#近期blog问题" class="headerlink" title="近期blog问题"></a>近期blog问题</h2><p>我很长一段时间弃管了这个blog,大约是十月到十二月，这段时间要复习准备期末考试，UIC相比于别的学校平时分给的多，所以期末不会捞太多</p><p>直到考Foundation of C Programming前一天晚上，我要进行复习，想起了我之前转载过阮一峰老师的C语言教程，遂打开看</p><p>于是我意识到 <strong>我的站挂了。</strong></p><p>因为那天要复习，所以我没去管太多，认为可能是cloudflare抽风了，等考试之后去更新下配置，不幸考完试就忘掉了</p><p>之后就是军训，因为广东天气炎热所以UIC的军训是在冬天，温度大概和东北的十月份左右差不多</p><p>然后<del>我把军训逃了</del></p><p>1月2日军训，我29号就回家了</p><p>之后HCC的群友也发现了这个站挂了，我也有时间搞这个，所以我去看了下github pages页</p><p>DNS check failed,然后与TLS相关的错误也有</p><p>于是我重新配置了下cloudflare的解析，在阿里云那边把DNS改到了cloudflare的，结果无限重定向</p><p>后来发现，cloudflare到github pages是http,而用户到cloudflare是https,于是我关掉了github pages的Enforce https,问题就解决了</p><p>上线几天，我一次装archlinux时看到有个地方之前改了一半，混乱不堪，于是我又进行了修改</p><p>我将把修复内容与这篇杂谈一起推送，并且修改了一些UI颜色配置，更改了背景图（文文。新闻 ke-ta老师的作品）</p><h2 id="近期听的音乐"><a href="#近期听的音乐" class="headerlink" title="近期听的音乐"></a>近期听的音乐</h2><p>我开始怀旧了，怀念前几年了</p><p>整理一下网课的年份：2020和2022年</p><p>我是从20年春季开始听鼠曲的，至今Strobe听了2139次（网易云计数），现在写这篇blog时候我还在听</p><p>Strobe是两个曲子合一起的，看到油管上的扒谱分析，简直是天才之作，天才、汗水、匠心缺一不可</p><p>Intro分成四段，每个衔接配合的精妙程度，只能用浑然天成来说</p><p>Lead的音色是使用Strobe合成器捏出来的，这个合成器现在是第二代，当时还是类似TUI的形式，没有真正意义上的GUI，它会模拟实体合成器在高电平时候的音高偏移，制作出这种迷幻的效果</p><p>有人尝试使用别的合成器进行还原，还没有成功过的</p><p>旋律营造出一种温暖而又凶险的景色，宁静秋夜中望月的感觉，凉风静止，月光温暖但脆弱，照在地上银色的质感</p><p>后来的弦乐，是可以让我沉浸在宁静而又优美的氛围中</p><p>后面浑然天成的渐进，音色设计和混音都很精细，是鼠曲一贯的常态，中段的转调和drop前的synth是令我最惊奇的</p><p>后来听了很多鼠曲，我评价为具有超级魔力的，甚至能给我生成很多不应属于我的记忆</p><p>只记得2009年冬天，和几个野生技术人员，深夜在朝着什么方向走。夜空清澈，群星闪烁，绿光紫光蓝光这种</p><p>我喜欢鼠曲，因为总能找到和我精神状态相符的曲子，或者能从中感受到什么或者看到什么</p><p>我想尽数追随印象中2009年的状态，可当时我现实中才三岁</p><p>我整了个网易云歌单叫【非常好Deadmau5】收集这些，它们总能给我带来2009年到2013年左右的幻境</p><p>至于别的，在20年后期听Melodic Techno，推荐德国制作人Recondite, 光头大佬，很强</p><p>22年和20年大致差不多，听了Deadmau5没发的一些ID,比如之前的Hit Save和The hive</p><p>Hit Save是唯一有可能超越Strobe的曲子，而The Hive只是一个很早的也很短的Trance罢了，但是有那种很积极的感觉，现在的曲子所不具备的感觉</p><p>还有别的，不过最核心的说完了</p><h2 id="近期的状态"><a href="#近期的状态" class="headerlink" title="近期的状态"></a>近期的状态</h2><p>等待期末出分很紧张，不过还行，意料之外体育C-，看来是我逃体测的原因</p><p>提前回到了吉林，真是横着走，一身轻松了，学校那些焦躁的烂事和我无关了</p><p>物价还便宜，晚上到处去吃烤肉，几个想念馆子都吃一遍</p><p>还给驾照领了，最近被迫到哪去都开车来进行一个练车，不好的是晚上吃串不能喝酒了</p><p>带了一台7945HX+4060的R9000P回来，内存加到了32G</p><p>这个机器真的烫烫烫，7950X直接放本子里了</p><p>不过现在用arch,为了逃避逆天NVIDIA的驱动问题，使用 <del>核显直连</del></p><p>就是那个H55&#x2F;桌面zen4带的2CU小RDNA2,叫做Radeon 610M,不配有RX，是最弱的光追卡，不过可以正常睡眠&#x2F;唤醒</p><p>然后游戏使用prime-run开，这样可以跑在独显上，完美</p><h3 id="关于围棋"><a href="#关于围棋" class="headerlink" title="关于围棋"></a>关于围棋</h3><p><strong>我不会</strong></p><p>但是可以看到我的blog有一篇katago安装教程</p><p>小时候学过（6岁），定到10级，跑路，全忘</p><p>2022年时候重新审视，发现竟然如此高深莫测，黑白子在天圆地方无数变化，古今中外群星闪耀</p><p>被美到，重新开始跟柯洁的皮套人学，后来又跑路</p><p>当时拿katago到野狐上去下的，现在想起来太耻辱了，这不就是竞技游戏开挂么</p><p>现在继续跟雪糕进行一个学，希望这次不会半途跑路</p><hr><p>先说这么多吧</p>]]></content>
    
    
    
    <tags>
      
      <tag>Talk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 初步教程</title>
    <link href="/2024/08/21/git-guide/"/>
    <url>/2024/08/21/git-guide/</url>
    
    <content type="html"><![CDATA[<p>时光机，启动！</p><span id="more"></span><h2 id="版本控制系统（VCS）概述"><a href="#版本控制系统（VCS）概述" class="headerlink" title="版本控制系统（VCS）概述"></a>版本控制系统（VCS）概述</h2><h3 id="一个小情景"><a href="#一个小情景" class="headerlink" title="一个小情景"></a>一个小情景</h3><p>设想一下，如果你写了一个程序，它会有一个甚至多个源代码文件：<br><img src="/../img/git-guide/%E6%88%AA%E5%B1%8F2024-08-21%2015.57.47.png"><br>在这之后，你把它发布了（比如交作业）。<br>但是老师看完后，发现缺了功能，让你再进行修改；<br>你改完，又将它交上去了，但是老的功能又出了bug。<br>你很无奈，准备<strong>把它改回去，再在其基础上进行修改。</strong></p><p>这时候，你发现自己的<strong>第一版源代码被覆盖掉了！！</strong><br>然后你忘记了原来是怎样写的，遂PDF并重写。。</p><p>你发现，如果在第一版文件写成后<strong>将其存档，记为一个版本</strong>，这样就不会发生这种事了。<br>你可以在第二版被驳回后，返回到第一版并继续修改。<br>当然Git的功能远不止这些。</p><h3 id="VCS概念"><a href="#VCS概念" class="headerlink" title="VCS概念"></a>VCS概念</h3><div class="note note-info">            <p>有时候，一个程序同时存有两个以上的版本有其必要性，例如：发布版本中程序错误已经被修正，但没有加入新功能；而开发版本则有新的功能正在开发、也有新的错误待解决，于是便需要同时维护两个不同的版本。</p><p>此外，为了找出只存在于某一特定版本中的程序错误、或找出程序错误出现的版本，开发人员也必须通过比对不同版本的源代码以找出问题的位置。</p>          </div><p>我们可以使用版本控制器来：</p><ul><li>对一个目录中的内容创建不同版本</li><li>创建不同的时间线（分支）</li><li>切换到任意版本&#x2F;分支</li><li>比较各个版本中文件的差异</li></ul><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>我们要讲的Git，就是软件版本控制器中最著名的一个，也是应用最广的一个。<br>它由Linus Torvalds（Linux kernel项目创始人、主力开发者）使用C语言写成。<br>它负责管理了从Linux kernel v2.6至今的代码。<br>它是分布式的，意味着我们可以从其他机器获取更新版本的代码以及把我们的代码传输至其他机器上。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先要知道你使用的是什么平台。<br>各个平台的安装方式都是不同的。</p><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ol><li>Debian&#x2F;Ubuntu:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update<br>sudo apt install git<br><span class="hljs-comment"># 然后看提示，按Y键、回车</span><br></code></pre></td></tr></table></figure><ol start="2"><li>RHEL&#x2F;Rocky Linux&#x2F;Alma Linux&#x2F;CentOS&#x2F;Fedora</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo dnf up<br>sudo dnf <span class="hljs-keyword">in</span> git<br><span class="hljs-comment"># 如果无法正常运行，可能是版本太老，请使用以下命令</span><br>sudo yum update<br>sudo yum install git<br></code></pre></td></tr></table></figure><ol start="3"><li>Arch Linux&#x2F;Manjaro</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -Sy<br>sudo pacman -S git<br><span class="hljs-comment"># 回车</span><br></code></pre></td></tr></table></figure><ol start="4"><li>openSUSE&#x2F;SLE</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo zypper up<br>sudo zypper <span class="hljs-keyword">in</span> git<br></code></pre></td></tr></table></figure><ol start="5"><li>Gentoo Linux</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo emerge -a dev-vcs/git<br></code></pre></td></tr></table></figure><p>之后执行<code>git --version</code>：<br>如果有以下输出，安装就完成了：<br><img src="/../img/git-guide/%E6%88%AA%E5%B1%8F2024-08-21%2016.24.34.png"></p><h3 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h3><p>当然这需要新的macOS版本；<br>如果你还在用Catalina，请务必更新。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">xcode-select --install<br></code></pre></td></tr></table></figure><p>这样，执行：<code>git --version</code><br><img src="/../img/git-guide/%E6%88%AA%E5%B1%8F2024-08-21%2016.41.31.png"><br>就对了。</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><ol><li>如果是Windows 11并且使用了魔法，那么你大概是可以使用<code>winget</code>的。这是很方便的。<br>按<code>Win + R</code>输入<code>powershell</code>，</li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">winget install --id Git.Git -e --source winget<br></code></pre></td></tr></table></figure><p>即可。</p><ol start="2"><li>如果不幸的事，你不喜欢更新，在使用老掉牙的1803版Windows 10，或者不能使用魔法：<br>从 <a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a> 下载适应你OS的版本。<br><img src="/../img/git-guide/%E6%88%AA%E5%B1%8F2024-08-21%2016.52.01.png"><br>一般人下载第二个就可，之后一路无脑Next。</li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>你新建了一个文件夹，你将在里面放置你要管理的文件（或者已经放置了）<br>如何让Git管理它呢？使用下面命令即可让Git接管它。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br></code></pre></td></tr></table></figure><p><img src="/../img/git-guide/%E6%88%AA%E5%B1%8F2024-08-21%2017.04.03.png"><br>现在，目录下多了一个.git文件夹，它就是负责存放Git的配置文件以及相关版本数据的。</p><h3 id="添加文件到仓库"><a href="#添加文件到仓库" class="headerlink" title="添加文件到仓库"></a>添加文件到仓库</h3><p>我们现在添加一个文件<code>test</code>进去，它的内容是：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">This is a test file.<br>Now, its version is:<br>    1<br></code></pre></td></tr></table></figure><p>记住现在它的版本是1。<br>如果你在使用一些“花里胡哨”的shell插件，比如omz，你会发现：<br><img src="/../img/git-guide/%E6%88%AA%E5%B1%8F2024-08-21%2017.10.01.png"><br>Git发现有一个文件被更改了。<br>这时候它还没有把这个文件记录在案，我们需要这样<strong>把一个文件加入仓库</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p><code>test</code>文件就被加入仓库了。<br>如果那你想把目录下的<strong>全部文件加入仓库</strong>，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br></code></pre></td></tr></table></figure><p>这样全部文件都会加进来。</p><h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><p>好的，你的这份作业已经写好，正准备交给老师。<br>现在我们需要把这堆文件记录成一个版本，也就是<strong>提交</strong>动作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;Version 1！加入test文件&quot;</span><br></code></pre></td></tr></table></figure><p>后面的<code>-m</code>参数是必加不可的，它是用来描述这个版本大概是做了什么的。<br>这两个引号，必须是英文的。<br>当然随便写命令也可以执行成功，但是不建议这么做。<br>因为到后面你可能看不懂这个版本是干什么的。</p><p>这样这个版本就被存储了下来。</p><h3 id="修改与回档（版本回退）"><a href="#修改与回档（版本回退）" class="headerlink" title="修改与回档（版本回退）"></a>修改与回档（版本回退）</h3><p>不幸，老师不认可你这份作业。你需要改进它，于是你修改<code>test</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sed -i <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-string">&#x27;s/1/2/g&#x27;</span> <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>这个属于sed替换文本，看不懂无视就好。</p><p>现在<code>test</code>文件已经是第二版了！<br><img src="/../img/git-guide/%E6%88%AA%E5%B1%8F2024-08-21%2017.33.31.png"><br>现在我们可以看到，我们的文件内容中的“1”变成了“2”，同时Git也发现了这个文件更改。<br>好了，我们再重复上一步提交。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit -m <span class="hljs-string">&quot;Version 2！修改test文件&quot;</span><br></code></pre></td></tr></table></figure><p>老师看了一下，原来他的不认可是来自于一个拼写错误：it’s &#x3D;&gt; its，并非不满意那个版本号。<br>看来并不需要修改版本号，只需要修改拼写错误就行。</p><div class="note note-info">            <p>有同学会觉得这是小题大做了，我只修改个版本号为什么要用Git回退，直接改一下不就行了么？</p><p>我这里只是在演示功能。如果你写一些大的工程，很多地方的语句&amp;调用函数等可能经过比较大程度的修改甚至覆盖。<br>这样做可以完全回到原来的状态。</p>          </div><p>Git用HEAD表示当前的版本。前一个版本就是HEAD^，前两个版本就是HEAD^^。<br>往前100个版本可以写100个^，但是这肯定是不易数的，所以可以写成HEAD~100。</p><p>我们往前退一个版本，而且要回到前一个版本的已提交状态，所以我们：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard HEAD^<br></code></pre></td></tr></table></figure><p>现在查看下<code>test</code>文件的内容：<br><img src="/../img/git-guide/%E6%88%AA%E5%B1%8F2024-08-21%2017.53.55.png"><br><code>--hard</code>参数会回退到上个版本的已提交状态，<code>--soft</code>会回退到上个版本的未提交状态，<code>--mixed</code>会回退到上个版本已添加但未提交的状态。</p><p>然后你修改文件再提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sed -i <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-string">&quot;s/its/it&#x27;s/g&quot;</span> <span class="hljs-built_in">test</span><br>git add .<br>git commit -m <span class="hljs-string">&quot;Commit 2: fix spell issue.&quot;</span><br></code></pre></td></tr></table></figure><p>你可能觉得写<code>HEAD^</code>的方法过于笨拙，当然还有一种方法可以解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p><img src="/../img/git-guide/%E6%88%AA%E5%B1%8F2024-08-21%2018.17.22.png"><br>当然在这里，你的commit id和我的不会一样。<br>之后，如果你想回到哪个版本，就：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard 版本commit <span class="hljs-built_in">id</span><br></code></pre></td></tr></table></figure><p>这里的commit id不需要写全，当然写一两个字母也不行。主要是让Git分辨出来特定版本，又不与别的版本混淆就行。<br>比如前6个字符大概就可。</p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>你可能听说过一些平台，比如 Github, Gitlab等，这些都是Git远程仓库平台。<br>那么，如何使用这些远程仓库呢？</p><h3 id="Clone（克隆）"><a href="#Clone（克隆）" class="headerlink" title="Clone（克隆）"></a>Clone（克隆）</h3><p>没错，命令就是<code>git clone</code>。<br>后面接链接与本地目标目录。<br>比如，从Github克隆Linux内核的仓库到当前用户主目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/torvalds/linux.git ~/linux<br></code></pre></td></tr></table></figure><p>这后面名字可以自己起，但是建议维持原名，最多只在其基础上加点东西。<br>现在，远程的目录就被1:1复刻到你这里来了。</p><h3 id="Pull（拉取）"><a href="#Pull（拉取）" class="headerlink" title="Pull（拉取）"></a>Pull（拉取）</h3><p>过了一段时间，Linux内核源码的仓库更新了，而你的仓库还是旧版本，这时候该如何同步？<br>切换到仓库目录下，运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull<br></code></pre></td></tr></table></figure><p>这样仓库就会更新了。</p><h3 id="Push（推送）"><a href="#Push（推送）" class="headerlink" title="Push（推送）"></a>Push（推送）</h3><p>显然，Linux内核源码仓库是很严格的，只有官方人员才能提交代码。<br>所以，我们自己创建一个Github仓库用于演示：<br><img src="/../img/git-guide/%E6%88%AA%E5%B1%8F2024-08-21%2018.32.54.png"><br>创建之后，是这样的：<br><img src="/../img/git-guide/%E6%88%AA%E5%B1%8F2024-08-21%2018.33.21.png"><br>你看它下面都写出来了，如何给本地仓库设置远程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin https://github.com/zlicdt/Test.git<br>git branch -M main<br>git push -u origin main<br></code></pre></td></tr></table></figure><p>这样，远程仓库这辈子就有了。<br><img src="/../img/git-guide/%E6%88%AA%E5%B1%8F2024-08-21%2018.36.04.png"><br>（请忽略我用老邮箱进行提交导致的头像变动</p><h3 id="另请注意"><a href="#另请注意" class="headerlink" title="另请注意"></a>另请注意</h3><p>Github应该是在很久以前（似乎是2020-2021年间）禁止了只使用用户名+邮箱进行的提交。<br>我们可能遇到相关提示，并且有一大堆很麻烦的操作。<br>表面上是为了安全，实际上却是安全了，但更多的是推自家的github-cli，它可以概括为让你在CLI登录Github账号，从而正常进行推送。<br>建议都装一个。</p><h2 id="更新中，敬请期待……"><a href="#更新中，敬请期待……" class="headerlink" title="更新中，敬请期待……"></a>更新中，敬请期待……</h2>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么选择 Mac</title>
    <link href="/2024/08/12/why-choose-mac/"/>
    <url>/2024/08/12/why-choose-mac/</url>
    
    <content type="html"><![CDATA[<p>优势、以及购买型号推荐</p><span id="more"></span><h2 id="先前提要"><a href="#先前提要" class="headerlink" title="先前提要"></a>先前提要</h2><p>在2020年前，Mac一直是属于价格高，核心硬件配置低的代表。只有屏幕和机身是不能骂的。<br>因为早在2012年，MacBook Pro就已经开始使用1440p（也就是我们常说的2K，2560x1440）的分辨率了。<br>显示色域也是早早达到了100% sRGB的标准。<br>同样的，机身使用当时极度少有的CNC加工铝合金，是成本最高的一档。</p><p>然而核心硬件的素质很是低下，经常采用低压15w平台的双核Intel Core i5&#x2F;i7，性能在当时面对采用H35标压的友商，差距是不能接受的。<br>内存全部为板载，更换需要把内存颗粒吹下来再焊上更大容量的颗粒。<br>只有到后期，高端的15寸MacBook Pro才会搭载Intel H45和AMD Radeon移动端独显，然而最高级的型号也只是RX 5600M（是HBM显存！！）</p><p>直到Apple Silicon发布了，M1惊艳全场，但仍有很多兼容性问题。<br>需要通过Rosetta 2转译运行。<br>但是运行原生二进制时，在当年的笔记本市场是大杀四方了。<br>大约是5800H~11800H的水准。<br>说剪视频很强，其实很多插件不能用，而且也只是在导出方面有专用单元罢了。</p><p>我也一直拒绝买Mac，认为那是高价低配的，买Mac的是冲着外观、系统、屏幕、触控板去的。<br>而我，一个使用过各种恶劣机器的，用Arch的折腾患者，这种机器不适合我的人设。</p><p>然后终于，我高中毕业，考进了CDS，要买一台新机器。</p><h2 id="我拥有的设备"><a href="#我拥有的设备" class="headerlink" title="我拥有的设备"></a>我拥有的设备</h2><ol><li>神舟战神 Z7-DA5NP<br> 模具：蓝天 V155<br> CPU：i5-12500H@睿频4.5GHz<br> GPU：RTX 3050 Laptop 4G（Micron）<br> 内存：三星8G DDR4 3200MHz x 2 &#x3D; 16G<br> 硬盘：自带的打码固态，PCIE3.0 512G，主控群联<br> 屏幕：自行更换的NE156QHM-NY2，2K 165Hz 100% sRGB<br> 系统：如今作为Minecraft Server，使用Debian 12<br> 双风扇四铜管，纯塑料机身，miniDP和HDMI口只能连1080p 120Hz&#x2F;2K 60Hz，单M.2，又一个3.5寸SATA盘位</li><li>台式机<br> 板子：MSI MAG MORTAR B550M MAX WIFI<br> CPU：R7-5700X<br> GPU：[MSI SUPRIM] NVIDIA GeForce RTX 3080 LHR 10G<br> 内存：铭瑄DDR4 3200MHz 16G x 2 &#x3D; 32G（颗粒Micron）<br> 硬盘1：梵想 S790 PCIE4.0 1TB（主控MAP1602+长存白片，通过丝印无法查到颗粒信息，232层）<br> 硬盘2：三星 PM9A1 PCIE4.0 1TB（插在3.0的口）<br> 散热器：酷妈 暴雪 T620S 双风扇6热管</li></ol><h2 id="我买的机器"><a href="#我买的机器" class="headerlink" title="我买的机器"></a>我买的机器</h2><p>MacBook Pro (16-inch, Nov 2023, Three Thunderbolt 4 ports)<br>译：<br>MacBook Pro (16英寸, 2023年11月, 三个雷雳4接口)<br>苹果的特立独行导致这个官方翻译叫“雷雳4”，是我们通常说的“雷电4”。</p><p>CPU: M3 Max 16 Cores(12P + 4E, max turbo freq: 4.05GHz)<br>GPU: M3 Max 40 Cores<br>RAM: 48G LPDDR5 板载<br>SSD: 1T 板载（速度近似PCIE4.0，连接被命名为Apple Fabric）</p><h2 id="外在"><a href="#外在" class="headerlink" title="外在"></a>外在</h2><ol><li><p>屏幕<br> <strong>当今量产型号最强的miniLED显示器</strong>，在这。</p><p> 分辨率3456x2234<br> 最大亮度1600nit（显示HDR内容时）<br> Display P3色域（色域容积&gt;sRGB）</p></li><li><p>外放<br> 这是不用多说的。<br> 参考蓝天X170.</p></li></ol><h2 id="内在"><a href="#内在" class="headerlink" title="内在"></a>内在</h2><p>这是我要重中之重提及的。</p><ol><li><p>包管理<br> Mac本来不存在包管理器，但是提及Mac上的包管理器，人们都会想到<strong>Homebrew</strong><br> <a href="https://brew.sh/">https://brew.sh/</a><br> 你会发现，包括字体在内，都是可以使用brew安装的。<br> 这里有大量包，包括原生macOS程序，其他平台（如GNU&#x2F;Linux的移植）以及.app格式的应用。<br> Linux平台的软件，对于一个CST人是很重要的。当然原生Linux更好。<br> 广度大于Homebrew的应该只有Arch Linux official + cn + AUR了吧（笑<br> （（Debian&#x2F;Ubuntu的官方源竟然没有<code>fastfetch</code>！</p><p> 反观隔壁Windows，来自Linux的移植软件属实<strong>稀缺无比</strong>。<br> WSL2也是访问Windows目录困难，所以你需要开VSCode+WSL Remote插件连WSL。<br> 如果你使用WSL开Linux GUI软件，莫名其妙的问题太多，并且本来这也只是个简陋功能。<br> 并且Windows这边的包管理器，都<strong>严重依赖软件本家的获取途径，并且依赖软件的GUI安装程序</strong>（很多软件不支持自动化安装）。</p></li><li><p>字体渲染<br> 依赖Mac常有的高分辨率，Mac通常都是高ppi的。<br> 以至于macOS的字体渲染都能说“清晰、重实”。</p><p> 反观Windows那边，字体渲染是一个常常被提起的诟病。<br> Windows的字体渲染得发虚，以至于很多人都用<strong>MacType</strong>这个软件来模拟Mac的字体渲染。<br> 但是MacType在Windows 11中，不能应用在软件标题栏了。<br> 至此，让Windows认真渲染文字的方法只剩下开高缩放。</p><p> 但是谈到缩放这个方面，不知你有没有注意过：<br> Windows建议的缩放倍数是根据大部分软件GUI占用最小像素数时不挤到任务栏下面的缩放倍数。<br> 然而在这个缩放倍数下，Windows会把文字渲染得很奇怪。<br> 比如使用微软雅黑字体时，“大”这个字，你会发现中间这一行很细，很难看。<br> 然而，在你使用2K屏时，把缩放拉到200%以上，你会发现这个问题解决了。<br> 但是在200%的缩放下，很多软件都无法正常显示了，它的底边会挤到任务栏下面。<br> 你甚至没法把窗口缩小，因为鼠标不能移动到任务栏下面。<br> <strong>所以你需要换4K及以上的屏，并把缩放拉到200%以上。</strong></p><p> 这是个奇妙的问题，奇妙到头大。然而它在Mac上是不会存在的，任何字都显示得很好。</p></li><li><p>字体配置<br> 首先普及：<strong>字体回落</strong>这一概念</p> <div class="note note-info">            <p>“字体回落”用于指定一系列的字体选项，当首选字体不可用时，浏览器会按照这个列表尝试加载下一个可用的字体。这样，即使首选字体在用户的设备上不可用，页面仍然可以使用备选字体显示文本，从而保持设计的一致性。</p>          </div><p> 举个例子：<br> 你在使用VSCode撰写Markdown文章，就像我现在这样。<br> 然而你注意到，现在编辑器内显示的中文文字很丑，它大概是叫做“宋体”的字体。<br> 但是英文确是你在settings.json里设置的Cascadia Code等宽字体。</p><p> 这就涉及到了字体回落。<br> 在字体没有提供中文文字时，Windows会把中文文字以宋体显示。<br> 没错，这里的默认回落字体是宋体。</p><p> 如果你想使用好看一点的微软雅黑，你需要这么做：</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;editor.fontFamily&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Cascadia Code, &#x27;微软雅黑&#x27;&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p> 然而在Mac上，这个问题是不存在的。<br> 当你使用中文locale时，默认的回落字体是苹方。</p></li><li><p>Unix环境<br> 这个问题和上面的包管理器问题是同源的。<br> Mac上有大量的移植软件，几乎所有开发工具都有Mac版本。</p><p> 很多脚本，都默认你使用类Unix环境，它们使用bash或zsh。<br> 一旦到了Windows，它们是废的。<br> WSL2本质上是Hyper-V开的虚拟机，这样你的机器就又跑了个CPU分配相同、内存是总内存一半的虚拟机。<br> 而MSYS2 cygwin之类的项目，只是模拟环境，速度极慢不说，还有很多bug。</p><p> PowerShell固然是很强大的，但是它过于反直觉，而且命令记忆相当困难，速度也慢。<br> 现在有<code>oh-my-posh</code>项目，可以装上PowerShell版的OMZ，但是相比OMZ，功能差了很多。</p></li></ol><h2 id="型号推荐"><a href="#型号推荐" class="headerlink" title="型号推荐"></a>型号推荐</h2><p>我推所有16寸的机器。<br>不过根据现在考虑，还是等M4 Pro的？<br>M4 ST性能自然不用说，MT性能已经和M2 Max接近了。<br>只怕M4 Pro打平M3 Max残血「10P+4E」（笑</p><h2 id="结"><a href="#结" class="headerlink" title="结"></a>结</h2><p>总习惯把macOS和Windows比。<br>现在用Windows台式机，只打游戏和跑图。</p><p>其实Linux才是真正的强者，什么都可以自由配置&#x2F;选择。<br>缺点可能是没有公司做和自家发行版完美结合的硬件，<br>而且桌面环境相比macOS过于简陋了（笑</p><p>推荐Arch Linux，可以到我的blog翻安装教程。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Talk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GPG 入门教程</title>
    <link href="/2024/01/19/gpg-tourial/"/>
    <url>/2024/01/19/gpg-tourial/</url>
    
    <content type="html"><![CDATA[<p>如何使用这个最流行、最好用的加密工具之一</p><span id="more"></span><h1 id="什么是GPG"><a href="#什么是GPG" class="headerlink" title="什么是GPG"></a>什么是GPG</h1><p>1991年，程序员 <a href="https://en.wikipedia.org/wiki/Phil_Zimmermann">Phil Zimmermann</a> 为了避开政府监视，开发了加密软件PGP。这个软件非常好用，迅速流传开来，成了许多程序员的必备工具。但是，它是商业软件，不能自由使用。所以，自由软件基金会决定，开发一个 PGP 的替代品，取名为 GnuPG，也就是 GPG</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>GPG有两种安装方式。可以<a href="http://www.gnupg.org/download/index.en.html">下载源码</a>，自己编译安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs zsh">./configure<br>make<br>make install<br></code></pre></td></tr></table></figure><p>也可以安装编译好的二进制包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs zsh">pacman -S gnupg # Arch Linux<br>apt install gnupg # Debian 系<br>dnf in gnupg # RH 系<br>zypper in gnupg # 蜥蜴系<br></code></pre></td></tr></table></figure><h1 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h1><p>安装成功后，使用gen-ken参数生成自己的密钥</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">gpg --gen-key<br></code></pre></td></tr></table></figure><p>会输出</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">gpg (GnuPG) 2.4.3; Copyright (C) 2023 g10 Code GmbH<br>This is free software: you are free to change and redistribute it.<br>There is NO WARRANTY, to the extent permitted by law.<br><br>注意：使用 “gpg --full-generate-key” 以获得一个全功能的密钥生成对话框。<br><br>GnuPG 需要构建用户标识以辨认您的密钥。<br><br>真实姓名：<br></code></pre></td></tr></table></figure><p>这里需要按照问题填，填了回车，后按<code>O</code>确定</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs text">gpg (GnuPG) 2.4.3; Copyright (C) 2023 g10 Code GmbH<br>This is free software: you are free to change and redistribute it.<br>There is NO WARRANTY, to the extent permitted by law.<br><br>注意：使用 “gpg --full-generate-key” 以获得一个全功能的密钥生成对话框。<br><br>GnuPG 需要构建用户标识以辨认您的密钥。<br><br>真实姓名： zlicdt<br>电子邮件地址： xkicdt@163.com<br>您选定了此用户标识：<br>    “zlicdt &lt;xkicdt@163.com&gt;”<br><br>更改姓名（N）、注释（C）、电子邮件地址（E）或确定（O）/退出（Q）？<br></code></pre></td></tr></table></figure><p>然后它会让你“输入密码以保护您的新密钥”，<strong>这个密码最好填8位以上的</strong>，否则会</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">┌─────────────────────────────────────────────────────────────────────────────────────────┐<br>│ 警告：您输入了一个不安全的密码                                                               │<br>│                                                                                         │<br>│ A passphrase should be at least 8 characters long.                                      │<br>│                                                                                         │<br>│ &lt;无论如何都使用这个&gt;                                           &lt;输入新的密码&gt;                │<br>└─────────────────────────────────────────────────────────────────────────────────────────┘<br></code></pre></td></tr></table></figure><p>然后，它会</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">我们需要生成大量的随机字节。在质数生成期间做些其他操作（敲打键盘<br>、移动鼠标、读写硬盘之类的）将会是一个不错的主意；这会让随机数<br>发生器有更好的机会获得足够的熵。<br></code></pre></td></tr></table></figure><p>最终生成一个有效期为三年的 GPG key</p><h1 id="高级密钥生成"><a href="#高级密钥生成" class="headerlink" title="高级密钥生成"></a>高级密钥生成</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">gpg --full-gen-key<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">gpg (GnuPG) 2.4.3; Copyright (C) 2023 g10 Code GmbH<br>This is free software: you are free to change and redistribute it.<br>There is NO WARRANTY, to the extent permitted by law.<br><br>请选择您要使用的密钥类型：<br>   (1) RSA 和 RSA<br>   (2) DSA 和 Elgamal<br>   (3) DSA（仅用于签名）<br>   (4) RSA（仅用于签名）<br>   (9) ECC（签名和加密） *默认*<br>  (10) ECC（仅用于签名）<br> （14）卡中现有密钥<br>您的选择是？<br></code></pre></td></tr></table></figure><p>这里建议直接选择默认的 ECC</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs text">请选择您想要使用的椭圆曲线：<br>   (1) Curve 25519 *默认*<br>   (4) NIST P-384<br>   (6) Brainpool P-256<br>您的选择是？<br>请设定这个密钥的有效期限。<br>         0 = 密钥永不过期<br>      &lt;n&gt;  = 密钥在 n 天后过期<br>      &lt;n&gt;w = 密钥在 n 周后过期<br>      &lt;n&gt;m = 密钥在 n 月后过期<br>      &lt;n&gt;y = 密钥在 n 年后过期<br>密钥的有效期限是？(0)<br>密钥永远不会过期<br>这些内容正确吗？ (y/N) y<br><br>GnuPG 需要构建用户标识以辨认您的密钥。<br><br>真实姓名：<br></code></pre></td></tr></table></figure><p>后来就和上部分一样了</p><h1 id="密钥管理"><a href="#密钥管理" class="headerlink" title="密钥管理"></a>密钥管理</h1><h2 id="列出密钥"><a href="#列出密钥" class="headerlink" title="列出密钥"></a>列出密钥</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">gpg --list-keys<br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">pub   ed25519 2024-01-18 [SC] [有效至：2027-01-17]<br>      F624D1B3CC89BF5760DCF150A30A42DE01DE13B5<br>uid             [ 绝对 ] zlicdt &lt;xkicdt@163.com&gt;<br>sub   cv25519 2024-01-18 [E] [有效至：2027-01-17]<br></code></pre></td></tr></table></figure><p>第一行显示公钥特征（算法，Hash字符串和生成时间），第二行显示”用户ID”，第三行显示私钥特征</p><p>如果你要从密钥列表中删除某个密钥，可以使用delete-key参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">gpg --delete-key [用户ID]<br></code></pre></td></tr></table></figure><p><strong>不过这样的话，如果它对应一个私钥的话，需要先删掉私钥，它会给出命令提示</strong></p><h2 id="输出密钥"><a href="#输出密钥" class="headerlink" title="输出密钥"></a>输出密钥</h2><p>公钥文件以二进制形式储存，armor 参数可以将其转换为 ASCII 码显示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">gpg --armor --export [用户ID]<br></code></pre></td></tr></table></figure><p>类似地，export-secret-keys 参数可以转换私钥</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">gpg --armor --export-secret-keys<br></code></pre></td></tr></table></figure><h2 id="上传公钥"><a href="#上传公钥" class="headerlink" title="上传公钥"></a>上传公钥</h2><p>公钥服务器是网络上专门储存用户公钥的服务器。send-keys 参数可以将公钥上传到服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">gpg --send-keys [用户ID] --keyserver https://keys.openpgp.org<br></code></pre></td></tr></table></figure><p>使用上面的命令，你的公钥就被传到了服务器 subkeys.pgp.net，然后通过交换机制，所有的公钥服务器最终都会包含你的公钥</p><p>由于公钥服务器没有检查机制，任何人都可以用你的名义上传公钥，所以没有办法保证服务器上的公钥的可靠性。通常，你可以在网站上公布一个公钥指纹，让其他人核对下载到的公钥是否为真。fingerprint 参数生成公钥指纹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">gpg --fingerprint [用户ID]<br></code></pre></td></tr></table></figure><h2 id="导入密钥"><a href="#导入密钥" class="headerlink" title="导入密钥"></a>导入密钥</h2><p>除了生成自己的密钥，还需要将他人的公钥或者你的其他密钥输入系统。这时可以使用 import 参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">gpg --import [密钥文件]<br></code></pre></td></tr></table></figure><p>为了获得他人的公钥，可以让对方直接发给你，或者到公钥服务器上寻找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">gpg --keyserver https://keys.openpgp.org --search-keys [用户ID]<br></code></pre></td></tr></table></figure><h1 id="加密和解密"><a href="#加密和解密" class="headerlink" title="加密和解密"></a>加密和解密</h1><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">gpg --recipient [用户ID] --encrypt demo.txt<br></code></pre></td></tr></table></figure><p>这会在当前目录下生成一个 demo.txt.gpg 文件，cat 其中的内容发现是已经经过加密的，不可读取</p><p>这时候传输文件就是安全的</p><h2 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h2><p>对方收到加密文件以后，就用自己的私钥解密</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">gpg --decrypt demo.txt.gpg<br></code></pre></td></tr></table></figure><p>此时它会在 terminal 里直接输出文件内容<br>GPG 允许省略 decrypt 参数，直接可以达到相同的效果</p><h1 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h1><h2 id="对文件签名"><a href="#对文件签名" class="headerlink" title="对文件签名"></a>对文件签名</h2><p>有时我们不需要加密文件，只需要对文件签名，表示这个文件确实是我本人发出的。<br>sign 参数用来签名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">gpg --sign demo.txt<br></code></pre></td></tr></table></figure><p>运行上面的命令后，当前目录下生成 demo.txt.gpg 文件，这就是签名后的文件。这个文件默认采用二进制储存，如果想生成 ASCII 码的签名文件，可以使用 clearsign 参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">gpg --clearsign demo.txt<br></code></pre></td></tr></table></figure><p>运行上面的命令后 ，当前目录下生成demo.txt.asc文件，后缀名asc表示该文件是ASCII码形式的，现在这个可读了</p><p>如果想生成单独的签名文件，与文件内容分开存放，可以使用 detach-sign 参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">gpg --detach-sign demo.txt<br></code></pre></td></tr></table></figure><p>运行上面的命令后，当前目录下生成一个单独的签名文件 demo.txt.sig。该文件是二进制形式的，如果想采用 ASCII 码形式，要加上 armor 参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">gpg --armor --detach-sign demo.txt<br></code></pre></td></tr></table></figure><h2 id="签名-加密"><a href="#签名-加密" class="headerlink" title="签名+加密"></a>签名+加密</h2><p>上一节的参数，都是只签名不加密。如果想同时签名和加密，可以使用下面的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">gpg --local-user [发信者ID] --recipient [接收者ID] --armor --sign --encrypt demo.txt<br></code></pre></td></tr></table></figure><p>local-user 参数指定用发信者的私钥签名，recipient 参数指定用接收者的公钥加密，armor 参数表示采用 ASCII 码形式显示，sign 参数表示需要签名，encrypt 参数表示指定源文件</p><h2 id="验证签名"><a href="#验证签名" class="headerlink" title="验证签名"></a>验证签名</h2><p>我们收到别人签名后的文件，需要用对方的公钥验证签名是否为真。verify 参数用来验证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">gpg --verify demo.txt.asc demo.txt<br></code></pre></td></tr></table></figure><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ol><li>Paul Heinlein, <a href="http://www.madboa.com/geek/gpg-quickstart/">GPG Quick Start</a></li><li>Ubuntu help, <a href="https://help.ubuntu.com/community/GnuPrivacyGuardHowto">GnuPrivacyGuardHowto</a></li><li>KNL, <a href="http://www.bitflop.com/document/129">GnuPG Tutorial</a></li><li>Alan Eliasen. <a href="http://futureboy.us/pgp.html">GPG Tutorial</a></li><li><a href="http://www.gnupg.org/gph/en/manual.html">The GNU Privacy Handbook</a></li><li><a href="https://www.ruanyifeng.com/blog/2013/07/gpg.html">GPG入门教程 - 阮一峰的网络日志</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>GPG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo Fluid 主题安装 Gitalk</title>
    <link href="/2024/01/06/hexo-fluid-with-gitalk/"/>
    <url>/2024/01/06/hexo-fluid-with-gitalk/</url>
    
    <content type="html"><![CDATA[<p>给 Hexo 加个评论插件 Gitalk</p><span id="more"></span><h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><p>首先，看到这里的话，你应该已经在 Github Pages 上部署好 Hexo + Fluid 了罢<br>咱看 fluid 的配置文件，里面写好了<strong>评论插件：Options: utterances | disqus | gitalk | valine…</strong><br>咱要选的就是这个 gitalk，基于 Github issue，无论是作者还是读者，有个 Github 账号就能用</p><h2 id="建立用于存储评论的仓库"><a href="#建立用于存储评论的仓库" class="headerlink" title="建立用于存储评论的仓库"></a>建立用于存储评论的仓库</h2><p>因为是基于 issue，所以要开一个公共 github 存储库（已存在或创建一个新的 github 存储库）来开这些 issue<br><img src="/../img/hexo-fluid-with-gitalk/1.png"><br>就像这个一样，是空的，只要是 public 的就行</p><h2 id="创建-GitHub-Application"><a href="#创建-GitHub-Application" class="headerlink" title="创建 GitHub Application"></a>创建 GitHub Application</h2><a class="btn" href="https://github.com/settings/applications/new"  target="_blank">点这申请</a><p>然后这个像这样填就行<br><img src="/../img/hexo-fluid-with-gitalk/2.png"><br>记得<code>xxxxx</code>要改啊</p><h2 id="把主体用-npm-装上"><a href="#把主体用-npm-装上" class="headerlink" title="把主体用 npm 装上"></a>把主体用 npm 装上</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm i <span class="hljs-literal">--save</span> gitalk<br></code></pre></td></tr></table></figure><h1 id="嵌入"><a href="#嵌入" class="headerlink" title="嵌入"></a>嵌入</h1><p>然后回到<code>_config.yml</code><br>把</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br>    <span class="hljs-attr">comments:</span><br>        <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>        <span class="hljs-attr">type:</span> <span class="hljs-string">gitalk</span><br><br><span class="hljs-attr">gitalk:</span><br>    <span class="hljs-attr">clientID:</span> <br>    <span class="hljs-attr">clentSecret:</span> <br>    <span class="hljs-attr">repo:</span> <span class="hljs-string">gitalk-comments</span><br>    <span class="hljs-attr">owner:</span> <span class="hljs-string">xxxxx</span><br>    <span class="hljs-attr">admin:</span> [<span class="hljs-string">&#x27;xxxxx&#x27;</span>]<br>    <span class="hljs-comment"># 都改成自己的，前两个就在申请完 Github Application 的页面，repo 按照你的评论存储仓库填，owner 和 admin 都改成你自己的用户名</span><br></code></pre></td></tr></table></figure><p>然后重新<code>hexo d -g</code><br>这就完事了</p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何用 Electron 制作一个抽号的程序</title>
    <link href="/2023/01/02/random-makeing-note/"/>
    <url>/2023/01/02/random-makeing-note/</url>
    
    <content type="html"><![CDATA[<p>电子包写的随机抽号</p><span id="more"></span><a class="btn" href="https://github.com/acidec/random"  target="_blank">代码</a><h2 id="技术栈选择"><a href="#技术栈选择" class="headerlink" title="技术栈选择"></a>技术栈选择</h2><p>抽号机事给普通人用的，他们对于这些大概一窍不通，所以不能写纯 TUI 的。<br>要易用，有图形界面，像个正常软件一样，界面可以简单不能简陋。<br>我直接想到了电子包这个梗，简单易用出图形界面，会一点前端就行。<br><del>用电子包写软件，我们都有光明的未来</del></p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><p>首先你得有<code>nodejs</code>、可用的网络（别用残废的China Mainland局域网）、<code>git</code></p><a class="btn" href="https://nodejs.org/en"  target="_blank">nodejs</a><p>&amp;</p><a class="btn" href="https://mirrors.bfsu.edu.cn/github-release/git-for-windows/git/LatestRelease/"  target="_blank">git</a><h3 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git config <span class="hljs-literal">--global</span> user.name 名字 //可以随便填<br>git config <span class="hljs-literal">--global</span> user.email 邮箱 //要能用的，要是就看看代码也可以随便填<br>git config <span class="hljs-literal">--global</span> http.sslVerify false<br></code></pre></td></tr></table></figure><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">mkdir random &amp;&amp; <span class="hljs-built_in">cd</span> random<br>npm init<br></code></pre></td></tr></table></figure><p>然后他开始问问题，实话回答就行。</p><h3 id="启动脚本"><a href="#启动脚本" class="headerlink" title="启动脚本"></a>启动脚本</h3><p>最标准的，参考文档的启动脚本，创建一个<code>main.js</code>，填入以下内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> &#123; app, <span class="hljs-title class_">BrowserWindow</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;electron&#x27;</span>)<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">createWindow</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> win = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrowserWindow</span>(&#123;<br>    <span class="hljs-attr">width</span>: <span class="hljs-number">1600</span>,<br>    <span class="hljs-attr">height</span>: <span class="hljs-number">1000</span>,<br>    <span class="hljs-attr">title</span>:<span class="hljs-string">&quot;抽号机&quot;</span><br>  &#125;)<br><br>  win.<span class="hljs-title function_">loadFile</span>(<span class="hljs-string">&#x27;index.html&#x27;</span>)<br>&#125;<br><br>app.<span class="hljs-title function_">whenReady</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">createWindow</span>()<br>&#125;)<br><br>app.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;window-all-closed&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (process.<span class="hljs-property">platform</span> !== <span class="hljs-string">&#x27;darwin&#x27;</span>) app.<span class="hljs-title function_">quit</span>()<br>  &#125;)<br><br></code></pre></td></tr></table></figure><p>其意为启动一个1600x1200的窗口，标题为”抽号机”，渲染”index.html”</p><h3 id="渲染的HTML"><a href="#渲染的HTML" class="headerlink" title="渲染的HTML"></a>渲染的HTML</h3><p>名字在<code>main.js</code>里写了叫<code>index.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;css/bootstrap.css&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container-fluid&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container-fluid&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>这是什么？抽号机喵~<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hr</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border-top:1px dotted #ccc;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container-fluid&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>1/54，保留6号<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-info btn-lg&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;rollNumber();&quot;</span>&gt;</span>抽！<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container-fluid&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>结果：<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;result&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;script.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>班级有54个人，6号休学去写曲子了，把他留着。<br>引入了<code>BootStrap CSS</code>，去下载：</p><a class="btn" href="https://getbootstrap.com/docs/3.4/getting-started/"  target="_blank">BootStrap CSS</a><p>下载之后把三样东西都放到<code>random</code>文件夹下。<br><del>按钮变得好看起来</del></p><p>引入的外部js代码在<code>script.js</code>里。</p><h3 id="逻辑部分"><a href="#逻辑部分" class="headerlink" title="逻辑部分"></a>逻辑部分</h3><p>需要用代码实现预定范围的随机数生成，并将其返回显示。<br><code>index.html</code>里写了代码在<code>script.js</code>里。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">rollNumber</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">var</span> set = [];<br><span class="hljs-keyword">while</span>(set.<span class="hljs-property">length</span> &lt; <span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">var</span> r = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">53</span>) + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(set.<span class="hljs-title function_">indexOf</span>(r) === -<span class="hljs-number">1</span>) set.<span class="hljs-title function_">push</span>(r);<br>&#125;<br> <br><span class="hljs-title function_">displayResult</span>(set);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">displayResult</span>(<span class="hljs-params">set</span>)&#123;<br>set.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;, &quot;</span>);<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;result&#x27;</span>).<span class="hljs-property">innerHTML</span>=<span class="hljs-string">&quot;&lt;center&gt;&lt;h1 class=&#x27;text-primary&#x27;&gt;&quot;</span>+set+<span class="hljs-string">&quot;&lt;/h1&gt;&lt;/center&gt;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>从1-54号中抽一个并返回。</p><h2 id="跑"><a href="#跑" class="headerlink" title="跑"></a>跑</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm run <span class="hljs-built_in">start</span><br></code></pre></td></tr></table></figure><p>启动一个Electron窗口，就是这个。呐，跑起来了。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>这是我放在 Github 上的代码的目录结构。<br>建议在获取之后运行下面代码更新 npm 包</p><p><code>npx npm-check-updates -u</code></p><ul><li><p>.gitignore -&gt; 忽略一些构建生成和node modules，要不这几百M放Github上每次还得更新</p></li><li><p>forge.config.js -&gt; 打包工具的依赖</p></li><li><p>index.html -&gt; 网页</p></li><li><p>main.js -&gt; 启动脚本</p></li><li><p>package(-lock).json -&gt; npm的购物清单</p></li><li><p>script.js -&gt; JavaScript代码</p></li><li><p>namelist.json -&gt; new feature的名单，已打码（new feature暂时还未实现、、</p></li><li><p>css &amp; fonts &amp; js -&gt; Bootstrap CSS</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Electron</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KataGo 安装</title>
    <link href="/2022/12/15/katago/"/>
    <url>/2022/12/15/katago/</url>
    
    <content type="html"><![CDATA[<p>现在开源的最强围棋AI。elo大概13k+？</p><span id="more"></span><p>源代码可用。 <a href="https://github.com/lightvector/KataGo">Github link</a>.</p><h2 id="获取模型文件"><a href="#获取模型文件" class="headerlink" title="获取模型文件"></a>获取模型文件</h2><p>如果你有现代GPU（比如GCN1.0&#x2F;Volta往后的），我建议用 OpenCL 版本。核显也是能跑的。<br>没卡或者卡太老的话，用 Eigen 这个用 CPU 跑的版本。还有支持 AVX2 的，要求4代 Core 以后了。<br>CUDA 版本配置过于繁琐，而且必须要用N卡。<br>Windows:</p><a class="btn" href="https://github.com/lightvector/KataGo/releases/download/v1.14.0/katago-v1.14.0-opencl-windows-x64.zip"  target="_blank">openCL</a><p>&amp;&amp;</p><a class="btn" href="https://github.com/lightvector/KataGo/releases/download/v1.14.0/katago-v1.14.0-eigenavx2-windows-x64.zip"  target="_blank">Eigen AVX2</a><p>Linux:</p><a class="btn" href="https://github.com/lightvector/KataGo/releases/download/v1.14.0/katago-v1.14.0-opencl-linux-x64.zip"  target="_blank">openCL</a><p>&amp;&amp;</p><a class="btn" href="https://github.com/lightvector/KataGo/releases/download/v1.14.0/katago-v1.14.0-eigenavx2-linux-x64.zip"  target="_blank">Eigen AVX2</a><p><strong>把这些解压，一会要用</strong></p><h2 id="下-KaTrain"><a href="#下-KaTrain" class="headerlink" title="下 KaTrain"></a>下 KaTrain</h2><p>官方推荐的 KataGO GUI<br><img src="/../img/katago/1.png"></p><a class="btn" href="https://github.com/sanderland/katrain"  target="_blank">Github Link</a><p>三平台运行支持，但是</p><ul><li>官方没有 Linux 版，需要自己编译;</li><li>macOS 版本不支持 aarch64，要用 Rosetta 2 转译</li></ul><p>Windows:</p><a class="btn" href="https://github.com/sanderland/katrain/releases/download/v1.14.0/KaTrain.exe"  target="_blank">Download</a><p>解压然后运行 <code>KaTrain.exe</code> -&gt;<br><img src="/../img/katago/2.png"><br>打开菜单，选择 <code>General &amp; Engine Settings</code> -&gt;<br><img src="/../img/katago/3.png"><br>把模型路径放到<code>Path to KataGo executable</code>里.</p><h2 id="还有"><a href="#还有" class="headerlink" title="还有"></a>还有</h2><p><code>Maximum number of visits in analysis</code>越大，这个 AI 越强<br><img src="/../img/katago/4.png"></p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Arch Linux 部署 Docker</title>
    <link href="/2022/11/29/archlinux-deploy-docker/"/>
    <url>/2022/11/29/archlinux-deploy-docker/</url>
    
    <content type="html"><![CDATA[<p>Docker，每个人都爱用……</p><span id="more"></span><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><ul><li>Arch Linux x86_64</li><li>大于2GB的RAM</li><li><code>root</code> 权限</li></ul><h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><ol><li>通过 <code>pacman</code> 安装 <code>docker</code> 软件包 -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S docker<br></code></pre></td></tr></table></figure></li><li>在系统启动时自动启动 <code>docker</code> 守护程序 -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl <span class="hljs-built_in">enable</span> docker<br></code></pre></td></tr></table></figure></li><li>启动 <code>docker</code> 服务 -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl start docker<br></code></pre></td></tr></table></figure></li><li>加入能够使用 <code>docker</code> 守护程序的 <code>docker</code> 组 -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo usermod -G docker -a <span class="hljs-variable">$USER</span><br></code></pre></td></tr></table></figure></li><li>重新启动 <code>docker</code> 守护程序 -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl restart docker<br></code></pre></td></tr></table></figure></li></ol><hr><h2 id="后续部分"><a href="#后续部分" class="headerlink" title="后续部分"></a>后续部分</h2><ol><li>验证 <code>docker</code> 是否在运行 -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker version<br></code></pre></td></tr></table></figure></li><li>运行下面的命令将从 <code>dockerhub</code> 拉取并运行“Hello World” docker 容器 -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run archlinux<br></code></pre></td></tr></table></figure></li></ol><h2 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h2><ol><li>列出容器镜像 -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker image <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure> <img src="/../img/archlinux-deploy-docker/1.png"></li><li>列出所有容器 -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker container <span class="hljs-built_in">ls</span> -a<br></code></pre></td></tr></table></figure> <img src="/../img/archlinux-deploy-docker/2.png"></li><li>删除容器 -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker container <span class="hljs-built_in">rm</span> CONTAINER_NUMBER<br></code></pre></td></tr></table></figure> 对于这个 <code>CONTAINER_NUMBER</code>，也支持简写。</li><li>删除镜像 -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker image <span class="hljs-built_in">rm</span> -f IMAGE_NUMBER<br></code></pre></td></tr></table></figure> 这个 <code>IMAGE_NUMBER</code> 也支持简写。</li><li>启动 <code>Linux</code> 镜像并进行 <code>chroot</code> 进入 -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it --name arch-test archlinux<br></code></pre></td></tr></table></figure> 这个命令是创建一个名为 <code>arch-test</code> 的容器，使用 <code>archlinux</code> 镜像作为模板并进行 <code>chroot</code> 进入。<br> <img src="/../img/archlinux-deploy-docker/3.png"><br> 使用 <code>docker ps</code> 命令查看容器信息。<br> <img src="/../img/archlinux-deploy-docker/4.png"></li></ol>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何用 C++ 快速撑爆内存？</title>
    <link href="/2009/03/16/cpp-fast-out-of-memory/"/>
    <url>/2009/03/16/cpp-fast-out-of-memory/</url>
    
    <content type="html"><![CDATA[<p>节约内存，请（（</p><span id="more"></span><h2 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nya</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">int</span>* ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">nya</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>反复创建新指针并分配一些内存空间。由于 <code>while(true)</code> 是无限循环的，内存会很快被填满。</strong></p><div class="note note-warning">            <p>由于这个程序会占满内存，不会自动<code>kill</code>进程的操作系统（如Windows、macOS）将使用<code>swap</code>进行内存交换。<br>这可能导致大量写入磁盘！<br>在Windows上，它会导致系统不稳定甚至出现黑屏。在严重情况下，未保存的数据可能会丢失并且可能出现蓝屏。请确保在运行此程序之前已保存所有数据。</p>          </div><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p><strong>在现代Linux发行版（x86_64 Linux-6.6.1-ARCH），当内存满时，进程将被终止。<br>在macOS（arm64 Darwin 22.1.0）上，它将占用<code>swap</code>到最大限制，并且进程将不会被终止。<br>Windows（x86_64 NT10）不会终止进程，在内存满时屏幕会变黑。可能已经无法给核显驱动内存了罢（笑</strong></p>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
