<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Arch Linux 安装教程</title>
    <link href="/2026/02/10/archlinux-installation/"/>
    <url>/2026/02/10/archlinux-installation/</url>
    
    <content type="html"><![CDATA[<p><strong>此文章适用于现代（2010年及以后）的x86_64机器</strong></p><span id="more"></span><p>截至教程发布日，Arch Linux Live CD的最新版本是2025年12月的，测试无误。</p><h2 id="支持的硬件"><a href="#支持的硬件" class="headerlink" title="支持的硬件"></a>支持的硬件</h2><p><strong>·x86_64架构的CPU，建议为2008年以后的CPU，比如 Intel Core i系列之后的以及AMD FX<br>·至少有1GB内存（Arch Wiki上写的最小的512MB现在已经无法启动如今的Live CD）<br>·可用的网络连接<br>·20GB可用的硬盘空间</strong></p><h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><h3 id="制作安装介质"><a href="#制作安装介质" class="headerlink" title="制作安装介质"></a>制作安装介质</h3><ol><li>到镜像站去下载最新的Arch Linux Live CD iso -&gt;<br><code>https://mirrors.ustc.edu.cn/archlinux/iso/latest/archlinux-x86_64.iso</code></li><li>使用工具将其写入到USB驱动器或者刻录光盘（不建议）<br> 推荐写入工具<a href="https://mirrors.bfsu.edu.cn/github-release/balena-io/etcher/LatestRelease/">balenaEtcher</a></li><li>重启后按主板厂商的指引设置USB启动或选择USB启动（若失败请先关闭安全启动[^1]）</li><li>从USB驱动器引导后就进入了Live CD环境</li></ol><div class="note note-info">            <p>如果这一步循环重启，并且Systemd log输出往往是到和网络相关的部分卡住<br>关机，然后拔掉电源线，等待十秒以上再插电开机</p>          </div><h3 id="Live-CD设置"><a href="#Live-CD设置" class="headerlink" title="Live CD设置"></a>Live CD设置</h3><ol><li>连接网络 -&gt;<br> <strong>WIFI:</strong> <div class="code-wrapper"><pre><code class="hljs bash">iwctl station wlan0 scaniwctl station wlan0 get-networksiwctl station wlan0 connect <span class="hljs-variable">$SSID</span> --passphrase <span class="hljs-variable">$WIFI_PASSWORD</span> <span class="hljs-comment">#$SSID代表WIFI的名字，$PASSWORD代表密码</span>ip addr</code></pre></div> <strong>如果直接插网线的话上面的步骤可以跳过</strong> <div class="note note-info">            <p>如果没有<code>wlan0</code>的话，可能是没有无线网卡或者是没有驱动，请插网线。如果没有RJ45网口，请更换无线网卡至AX210（<br>对于另一种情况（通常和上面提到的循环重启绑定），参见下面的内容<br>若<code>ip addr</code>返回了wlan0的信息并且下面有正确的ip，则代表网络已连接成功。</p>          </div> <div class="note note-warning">            <p>遇到循环重启的情况下，通常正常开机之后无线网卡被block了，需要手动unblock</p><div class="code-wrapper"><pre><code class="hljs bash">rfkill unblock all</code></pre></div><p>之后和正常的操作方式并无差异</p>          </div> 可选：停止<code>reflector</code>服务，防止<code>/etc/pacman.d/mirrorlist</code>被写入其他地区镜像 -&gt; <div class="code-wrapper"><pre><code class="hljs bash">systemctl stop reflector.service</code></pre></div></li><li>配置镜像<br> 国内网络环境懂得都懂，用镜像（注意：这一步须在<code>reflector.service</code>停止后进行，可手动结束或等待其执行完成，否则编辑完的<code>mirrorlist</code>会被它重写） -&gt; <div class="code-wrapper"><pre><code class="hljs bash">vim /etc/pacman.d/mirrorlist</code></pre></div><ul><li>在文件开头按<code>i</code>进入<code>insert</code>模式，添加<code>Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch</code></li><li>按<code>esc</code>退出<code>insert</code>模式，输入<code>:wq</code>保存并退出<code>vim</code></li></ul></li><li>（可选）ssh 远程连接<br> 远程访问，可以直接复制命令。 <div class="code-wrapper"><pre><code class="hljs bash">ip a</code></pre></div> 看 wlan0（如果是 WIFI 连接）下面的信息，这里会显示联网后本机在局域网内被分配的ip地址。记下它。<br> 然后我们设置这台机器 root 用户的密码： <div class="code-wrapper"><pre><code class="hljs bash">passwd</code></pre></div> 这里随便设一个，只要你能记住。<br> 我这里假设这台机器的ip是 192.168.101.12，于是在另一台在同一个局域网的机器上，执行 <div class="code-wrapper"><pre><code class="hljs bash">ssh root@192.168.101.12</code></pre></div> 然后按提示，输入<code>yes</code>，再输入刚才设置的密码，就可以连接了。</li></ol><h3 id="磁盘相关"><a href="#磁盘相关" class="headerlink" title="磁盘相关"></a>磁盘相关</h3><ol><li>磁盘分区 -&gt; <div class="note note-warning">            <p>这一步需要按照情况自行更改，操作不当会导致数据丢失。一定要理解下面info中的内容。</p>          </div> <div class="note note-info">            <p>我这台机器有一个NVME接口的固态硬盘，它的编号是<code>nvme0n1</code>。在有多个NVME接口的主板上，如果你插了多块硬盘，它将会有<code>nvme1n1</code>、<code>nvme2n1</code>等编号，一定要清楚自己要操作的是哪块硬盘。连在SATA与USB接口上的硬盘会显示<code>sda</code>、<code>sdb</code>等，<code>sda</code>可能是U盘也可能是内置硬盘，请先<code>lsblk</code>进行辨认。这条命令的意义是对<code>nvme0n1</code>进行操作，请根据自身需要更改。</p>          </div> <div class="code-wrapper"><pre><code class="hljs bash">cfdisk /dev/nvme0n1</code></pre></div> <div class="note note-warning">            <p>如果先前有Windows安装的话，请注意不要把Windows分区直接缩小大小，会让Windows坏掉。应先使用其他工具完成分区大小调整再进行后续步骤。</p>          </div><ul><li>使用GPT分区表（这是UEFI引导的必须条件）</li><li>推荐分区方案 -&gt;<ul><li>EFI分区：不小于4MB，类型：<code>EFI System</code></li><li>主分区：不小于10GB，类型：<code>Linux filesystem</code><br>  （建议在分区内部建立一个swapfile来承担swap的任务）<br>  <img src="/../img/archlinux-installation/1.png"></li></ul></li><li>结束后，选<code>Write</code>再输入<code>yes</code>来写入分区表，再选<code>Quit</code>退出</li></ul></li><li>建立文件系统 -&gt;<br> 主分区使用<code>btrfs</code>文件系统 <div class="note note-warning">            <p>如果先前安装了Windows或者其他操作系统，不要执行第一条，会导致Windows引导损坏。</p>          </div> <div class="note note-info">            <p>这条命令也需要自行修改，意为在<code>nvme0n1</code>的第一分区创建<code>vfat</code>文件系统，在<code>nvme0n1</code>的第二分区创建<code>ext4</code>文件系统。</p>          </div> <div class="code-wrapper"><pre><code class="hljs bash">mkfs.vfat /dev/nvme0n1p1mkfs.btrfs /dev/nvme0n1p2</code></pre></div> <div class="note note-info">            <p>如果之前<code>nvme0n1p2</code>建立过其他文件系统，这里需要按<code>y</code>确认。</p>          </div></li><li>挂载分区 -&gt; <div class="note note-info">            <p>改，勿照抄。<code>/</code>的<code>nvme0n1p2</code>挂载到<code>/mnt</code>，再把<code>nvme0n1p1</code>这个EFI分区挂到<code>/mnt/boot/efi</code>下。</p>          </div> <div class="code-wrapper"><pre><code class="hljs bash">mount /dev/nvme0n1p2 /mnt<span class="hljs-built_in">mkdir</span> -p /mnt/boot/efimount /dev/nvme0n1p1 /mnt/boot/efi</code></pre></div></li><li>创建<code>swapfile</code> -&gt; <div class="note note-info">            <p><code>swap</code>的用途是在内存不足时，将硬盘的一部分作为内存的扩展空间使用。这里<code>swap</code>创建为8G，可根据需要改变<code>count=</code>后的数字，单位是MB。当然如果内存够大也可以不用执行这些命令。</p>          </div> <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=/mnt/swapfile bs=1M count=8192<span class="hljs-built_in">chmod</span> 600 /mnt/swapfilemkswap /mnt/swapfileswapon /mnt/swapfile</code></pre></div></li></ol><h3 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h3><ol><li>安装软件包 -&gt;<br> <strong>首先初始化keyring！！</strong> <div class="code-wrapper"><pre><code class="hljs bash">pacman -Sy archlinux-keyring</code></pre></div><h4 id="使用KDE-Plasma作桌面环境的系统"><a href="#使用KDE-Plasma作桌面环境的系统" class="headerlink" title="使用KDE Plasma作桌面环境的系统"></a><strong>使用KDE Plasma作桌面环境的系统</strong></h4> <code>pacstrap</code>安装必要的包 <div class="code-wrapper"><pre><code class="hljs bash">pacstrap /mnt base linux-zen linux-firmware linux-zen-headers base-devel git zsh zsh-completions bash-completion grub efibootmgr networkmanager openssh vim plasma kde-utilities kde-system fcitx5-chinese-addons fcitx5-gtk fcitx5-configtool firefox fastfetch btop</code></pre></div><h4 id="使用GNOME作桌面环境的系统"><a href="#使用GNOME作桌面环境的系统" class="headerlink" title="使用GNOME作桌面环境的系统"></a><strong>使用GNOME作桌面环境的系统</strong></h4> <div class="code-wrapper"><pre><code class="hljs bash">pacstrap /mnt base linux-zen linux-firmware linux-zen-headers base-devel git zsh zsh-completions bash-completion grub efibootmgr networkmanager openssh vim gnome noto-fonts-cjk noto-fonts-emoji noto-fonts-extra ibus ibus-libpinyin firefox fastfetch btop</code></pre></div><h4 id="使用命令行界面的系统-Headless"><a href="#使用命令行界面的系统-Headless" class="headerlink" title="使用命令行界面的系统(Headless)"></a><strong>使用命令行界面的系统(Headless)</strong></h4> 这是我的习惯 -&gt; <div class="code-wrapper"><pre><code class="hljs bash">pacstrap /mnt base linux-zen linux-firmware linux-zen-headers base-devel git zsh zsh-completions bash-completion grub efibootmgr networkmanager openssh vim fastfetch btop tmux</code></pre></div><h4 id=""><a href="#" class="headerlink" title=""></a></h4></li><li>生成<code>fstab</code> -&gt; <div class="code-wrapper"><pre><code class="hljs bash">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</code></pre></div></li><li><code>chroot</code>到新系统 -&gt; <div class="code-wrapper"><pre><code class="hljs bash">arch-chroot /mnt</code></pre></div></li></ol><h3 id="初步配置系统"><a href="#初步配置系统" class="headerlink" title="初步配置系统"></a>初步配置系统</h3><ol><li>时间设置 -&gt; <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtimehwclock --systohc</code></pre></div></li><li>用户设置 -&gt; <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> archlinux &gt; /etc/hostnameuseradd -m <span class="hljs-variable">$NEW_USERNAME</span> -G wheelpasswd <span class="hljs-variable">$NEW_USERNAME</span></code></pre></div> <div class="note note-info">            <p><code>useradd</code>用于添加账户，<code>passwd</code>用于修改密码，为安全考虑输入的密码不会直接显示出来。虽然没有反应，但确实是输入进去了。<br><code>-m</code>参数用以添加用户目录，<code>-G</code>参数用以将用户加入到<code>wheel</code>组中。这个组将会被赋予使用<code>sudo</code>的权力。</p>          </div></li><li>编辑<code>sudoers</code> -&gt; <div class="code-wrapper"><pre><code class="hljs bash">visudo</code></pre></div> 将文件中的<code># %wheel ALL=(ALL:ALL) ALL</code>（大概率在第125行，使用<code>vim</code>按<code>:125</code>跳转）的注释取消，使得<code>wheel</code>组里的用户可以使用<code>sudo</code></li><li>配置<code>zsh</code> -&gt; <div class="note note-info">            <p>zsh 是一个有强大客制化能力的 shell，并且 Apple 也将新 macOS 默认的 shell 换成了 zsh。现在Arch Linux Live CD 的默认 shell 就是 zsh。<br>如果不喜欢zsh，或者考虑兼容性，请跳过这一步。</p>          </div> <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman -S grml-zsh-config</code></pre></div></li><li>本地化 -&gt; <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;LANG=\&quot;en_US.UTF-8\&quot;&quot;</span> &gt;&gt; /etc/locale.confsed -i <span class="hljs-string">&quot;s@#zh_CN.UTF-8 UTF-8@zh_CN.UTF-8 UTF-8@g&quot;</span> /etc/locale.gensed -i <span class="hljs-string">&quot;s@#en_US.UTF-8 UTF-8@en_US.UTF-8 UTF-8@g&quot;</span> /etc/locale.gen</code></pre></div> 此处命令意为去掉<code>#zh_CN.UTF-8 UTF-8</code>和<code>#en_US.UTF-8 UTF-8</code>的注释符号“<code>#</code>”<br> 最后运行 -&gt; <div class="code-wrapper"><pre><code class="hljs bash">locale-gen</code></pre></div></li><li>服务设置 -&gt; <div class="code-wrapper"><pre><code class="hljs bash">systemctl <span class="hljs-built_in">enable</span> NetworkManagersystemctl <span class="hljs-built_in">enable</span> sshdsystemctl <span class="hljs-built_in">enable</span> sddm <span class="hljs-comment"># KDE</span>systemctl <span class="hljs-built_in">enable</span> gdm <span class="hljs-comment"># GNOME</span></code></pre></div></li><li>引导设置 -&gt;<br> <code>gurb</code>已支持引导Windows。<br> 可以让<code>grub</code>找到Windows。 <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman -Sy ntfs-3g os-prober</code></pre></div> 对于<code>UEFI</code>引导的安装方式<br> <div class="code-wrapper"><pre><code class="hljs bash">grub-install --target=x86_64-efi --efi-directory=/boot/efised -i <span class="hljs-string">&quot;s@#GRUB_DISABLE_OS_PROBER=false@GRUB_DISABLE_OS_PROBER=false@g&quot;</span> /etc/default/grubgrub-mkconfig -o /boot/grub/grub.cfg</code></pre></div><br> 对于<code>BIOS</code>引导的安装方式<br> <div class="code-wrapper"><pre><code class="hljs bash">grub-install /dev/nvme0n1sed -i <span class="hljs-string">&quot;s@#GRUB_DISABLE_OS_PROBER=false@GRUB_DISABLE_OS_PROBER=false@g&quot;</span> /etc/default/grubgrub-mkconfig -o /boot/grub/grub.cfg</code></pre></div></li><li>退出<code>chroot</code>环境并重启 -&gt; <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">exit</span>reboot</code></pre></div><strong>至此Arch Linux的安装就完成了</strong><br><strong>接下来是配置部分</strong></li></ol><h3 id="进一步配置系统"><a href="#进一步配置系统" class="headerlink" title="进一步配置系统"></a>进一步配置系统</h3><p><strong>如果是KDE的话</strong>，重启系统后，大概就是这样的 -&gt;<br><img src="/../img/archlinux-installation/2.png"></p><ol><li><p>输入法配置<br> 首先把<code>Fcitx5</code>设为默认输入法并自动启动 -&gt;<br> 编辑 &#x2F;etc&#x2F;environment</p> <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> vim /etc/environment</code></pre></div><p> 把下面的东西加进去 -&gt;</p> <div class="code-wrapper"><pre><code class="hljs text">GTK_IM_MODULE=fcitxQT_IM_MODULE=fcitxXMODIFIERS=@im=fcitxSDL_IM_MODULE=fcitxGLFW_IM_MODULE=ibus</code></pre></div><p> 进入设置 -&gt; 键盘 -&gt; 虚拟键盘，并按使用的 Compositor 设置：<br> <img src="/../img/archlinux-installation/5.png"><br> 之后注意任务栏右下角的键盘图标：<br> 如果直接<code>右键</code>-<code>配置</code>是会显示这个的 -&gt;<br> <img src="/../img/archlinux-installation/3.png"><br> 这会进入文本配置，显然我们是不懂的（<br> 所以要安装<code>fcitx5-configtool</code> -&gt;</p> <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman -S fcitx5-configtool</code></pre></div><p> 然后再<code>右键</code>-<code>配置</code>就可以看到 -&gt;<br> <img src="/../img/archlinux-installation/4.png"></p><p> 重新登录就可以正常使用了<br> 更多用法请参阅<a href="https://wiki.archlinux.org/title/Fcitx5_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Arch Wiki</a></p></li><li><p>软件源<br> 众所周知，官方源对于灰色地带&#x2F;非自由软件是不收录的。<br> 所以我们通常用第三方源+<code>AUR</code>来进行补充。<br> 官方源是不带任何<code>AUR</code>工具的，所以我们先装<code>archlinuxcn</code>源 -&gt;</p> <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> vim /etc/pacman.conf</code></pre></div><p> 加入以下文本 -&gt;</p> <div class="code-wrapper"><pre><code class="hljs text">[archlinuxcn]Server = https://mirrors.bfsu.edu.cn/archlinuxcn/$arch</code></pre></div><p> 然后获取<code>keyring</code> -&gt;</p> <div class="note note-warning">            <p>（2024.9.7测试问题已解决，此部分的内容已过时，仅在后续出现类似问题时供参考用）<br>近期这一步会出现问题，因为archlinuxcn 社区源的 keyring 包 archlinuxcn-keyring 由 farseerfc 的 key 签署验证，而 Arch Linux 官方 keyring 中包含了 farseerfc 的 key 。自12月初 archlinux-keyring 中删除了一个退任的 master key (<a href="https://gitlab.archlinux.org/archlinux/archlinux-keyring/-/issues/246">https://gitlab.archlinux.org/archlinux/archlinux-keyring/-/issues/246</a>) 导致 farseerfc 的 key 的信任数不足，由 GnuPG 的 web of trust 推算为 marginal trust，从而不再能自动信任 archlinuxcn-keyring 包的签名。(转自Arch Linux CN Telegram Messages Channel)</p>          </div><p> 如果你在新系统中尝试安装<code>archlinuxcn-keyring</code>包时遇到如下报错：</p> <div class="code-wrapper"><pre><code class="hljs text">error: archlinuxcn-keyring: Signature from &quot;Jiachen YANG (Arch Linux Packager Signing Key) &lt;farseerfc@archlinux.org&gt;&quot; is marginal trust</code></pre></div><p> 请使用以下命令在本地信任 farseerfc 的 key 。此 key 已随<code>archlinux-keyring</code>安装在系统中，只是缺乏信任：</p> <div class="code-wrapper"><pre><code class="hljs shell">sudo pacman-key --lsign-key &quot;farseerfc@archlinux.org&quot;</code></pre></div><p> 然后</p> <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman -Sy archlinuxcn-keyring</code></pre></div><p> 就可以使用<code>archlinuxcn</code>源了！<br> 由于要使用<code>AUR</code>，所以我们先装一个AUR工具：</p> <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman -S paru</code></pre></div><p> 详细的用法和<code>pacman</code>一样。</p></li><li><p>引导Windows<br> 在安装系统时，<code>os-prober</code>往往不能正常检测到Windows，需要我们再运行</p> <div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> grub-mkconfig -o /boot/grub/grub.cfg</code></pre></div><p> 重启即可看到<code>Windows Boot Manager</code>。</p></li></ol><h2 id="显卡驱动"><a href="#显卡驱动" class="headerlink" title="显卡驱动"></a>显卡驱动</h2><p>如果是A卡和I卡，开源的驱动会做得很好</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman -S xf86-video-amdgpu <span class="hljs-comment"># AMD</span><span class="hljs-built_in">sudo</span> pacman -S xf86-video-intel <span class="hljs-comment"># Intel</span></code></pre></div><p>对于部分老显卡，可能不适用，需要移步 Arch Wiki 中相关部分<br><a href="https://wiki.archlinux.org/title/Xorg#Driver_installation">https://wiki.archlinux.org/title/Xorg#Driver_installation</a></p><p>而N卡，需要进行以下步骤</p><h3 id="查看显卡型号"><a href="#查看显卡型号" class="headerlink" title="查看显卡型号"></a>查看显卡型号</h3><div class="code-wrapper"><pre><code class="hljs bash">lspci -k | grep -A 2 -E <span class="hljs-string">&quot;(VGA|3D)&quot;</span></code></pre></div><p>GeForce 900 系以及更新的显卡（NV110+），安装 nvidia（用于官方源里的标准内核）或者 nvidia-lts（用于 linux-lts 内核）</p><p>Turing (NV160&#x2F;TUXXX) 系列或更新的显卡。可以安装 nvidia-open 包，开源的（仅适用于官方源里的内核，其他内核上必须使用 nvidia-open-dkms 包）</p><p>更老的显卡型号（发布于 2010 年或更早），就用内核自带的 Nouveau</p><h3 id="安装驱动"><a href="#安装驱动" class="headerlink" title="安装驱动"></a>安装驱动</h3><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman -S nvidia-open-dkms nvidia-settings</code></pre></div><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>安装 NVIDIA 官方的驱动之后，需要编辑<code>/etc/mkinitcpio.conf</code>，在 HOOKS 一行删除<code>kms</code>并保存</p><p>然后执行</p><div class="code-wrapper"><pre><code class="hljs bash">mkinitcpio -P</code></pre></div><p>重新生成一次镜像。这能防止 initramfs 包含 nouveau 模块，避免 nouveau 和官方驱动的冲突。</p><h3 id="笔记本双显卡配置"><a href="#笔记本双显卡配置" class="headerlink" title="笔记本双显卡配置"></a>笔记本双显卡配置</h3><p>因为笔记本经常遇到需要睡眠&#x2F;唤醒的情况，故不建议在使用Linux时开启独显直连</p><p>建议使用Intel&#x2F;AMD的核显，安装适用的驱动，还有渲染分载需要的NVIDIA PRIME</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman -S xf86-video-amdgpu <span class="hljs-comment"># AMD</span><span class="hljs-built_in">sudo</span> pacman -S xf86-video-intel <span class="hljs-comment"># Intel</span><span class="hljs-built_in">sudo</span> pacman -S nvidia-prime</code></pre></div><p>之后就可以愉快的使用 Wayland 作为显示协议</p><p>在需要使用 NVIDIA GPU 的时候（如游戏），使用</p><div class="code-wrapper"><pre><code class="hljs bash">prime-run xxx <span class="hljs-comment"># xxx为命令</span></code></pre></div><h2 id="常用软件"><a href="#常用软件" class="headerlink" title="常用软件"></a>常用软件</h2><ol><li>telegram</li></ol><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman -S telegram-desktop</code></pre></div><ol start="2"><li>Visual Studio Code（Official version）</li></ol><div class="code-wrapper"><pre><code class="hljs bash">paru -S visual-studio-code-bin</code></pre></div><ol start="3"><li>Wine<br>先启动 <code>/etc/pacman.conf</code> 中的 <code>multilib</code> 源，其中包含32位软件<br>不要直接复制这些命令，要先看好你的显卡是哪家的</li></ol><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman -S lib32-mesa <span class="hljs-comment"># 普通御三家卡</span><span class="hljs-built_in">sudo</span> pacman -S lib32-nvidia-utils <span class="hljs-comment"># 绿厂闭源驱动，效果好，需要现代N卡</span><span class="hljs-built_in">sudo</span> pacman -S lib32-amdgpu-pro-oglp <span class="hljs-comment"># 专业A卡</span><span class="hljs-built_in">sudo</span> pacman -S wine wine-gecko wine-mono lib32-alsa-lib lib32-alsa-plugins</code></pre></div><ol start="4"><li>Chrome &#x2F; Edge</li></ol><div class="code-wrapper"><pre><code class="hljs bash">paru -S microsoft-edge-stable-bin <span class="hljs-comment"># 莫名慢速下载警告</span>paru -S google-chrome</code></pre></div><ol start="5"><li>网易云音乐<br>现在可以使用Web版：<a href="https://music.163.com/st/webplayer">https://music.163.com/st/webplayer</a><br>因为原版好像似了一半，所以使用替代版<br>Go 写的 musicfox，TUI 版网易云</li></ol><div class="code-wrapper"><pre><code class="hljs bash">paru -S go-musicfox-git</code></pre></div><p>原版:</p><div class="code-wrapper"><pre><code class="hljs bash">paru -S netease-cloud-music</code></pre></div><ol start="6"><li>Steam</li></ol><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman -S steamparu -S proton</code></pre></div><ol start="7"><li>Clash Verge Reversion<br>这是一个 Clash Verge 的修复版本，解决了原版无法更新订阅的问题</li></ol><div class="code-wrapper"><pre><code class="hljs bash">paru -S clash-verge-rev</code></pre></div><h2 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h2><h3 id="替换-ls-与-cat"><a href="#替换-ls-与-cat" class="headerlink" title="替换 ls 与 cat"></a>替换 ls 与 cat</h3><p>ls -&gt; eza<br>cat -&gt; bat<br>这两个是用Rust写的升级版</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman -S eza bat</code></pre></div><p>将如下内容填入 ~&#x2F;.zshrc</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">alias</span> <span class="hljs-built_in">ls</span>=<span class="hljs-string">&quot;eza&quot;</span><span class="hljs-built_in">alias</span> <span class="hljs-built_in">cat</span>=<span class="hljs-string">&quot;bat&quot;</span></code></pre></div><h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><p>对于 zsh, 我推荐 Powerlevel10k。<br>它的 Github 仓库链接是<code>https://github.com/romkatv/powerlevel10k</code><br>当你添加了 archlinuxcn 源之后，你可以</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman -S zsh-theme-powerlevel10k-git</code></pre></div><p>创建<code>~/.zshrc</code>并加入<code>source /usr/share/zsh-theme-powerlevel10k/powerlevel10k.zsh-theme</code><br>在这里如果你直接运行<code>source ~/.zshrc</code>，你会发现这里有很多图标不能显示。<br>所以要安装「高级」的字体，也就是打了补丁的 Nerd Fonts。这是一个系列，加入了很多图标。<br>我喜欢 Meslo Font，你也可以换成别的，比如 <code>ttf-jetbrains-mono-nerd</code></p><div class="code-wrapper"><pre><code class="hljs bash">paru -S ttf-meslo-nerd</code></pre></div><p>重启Konsole, 然后新建配置文件，更改字体，<br>然后<code>source ~/.zshrc</code>并运行<code>p10k configure</code>就可。</p><h3 id="字体配置"><a href="#字体配置" class="headerlink" title="字体配置"></a>字体配置</h3><p>一天你打开浏览器，看到了抽象的日本字体，比如<span lang="ja">关</span>、<span lang="ja">复</span>的字形过窄，<span lang="ja">门</span>的点变成了竖插在上面……<br>这是不可接受的。<br>于是你执行<code>mkdir -p ~/.config/fontconfig &amp;&amp; vim ~/.config/fontconfig/fonts.conf</code><br>把以下内容写了进去：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">fontconfig</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;fonts.dtd&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">fontconfig</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">alias</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>sans-serif<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">prefer</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Noto Sans CJK SC<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Noto Sans CJK TC<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Noto Sans CJK JP<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">prefer</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">alias</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">alias</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>monospace<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">prefer</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Noto Sans Mono CJK SC<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Noto Sans Mono CJK TC<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Noto Sans Mono CJK JP<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">prefer</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">alias</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">fontconfig</span>&gt;</span></code></pre></div><p>并<code>fc-cache -fv</code><br>问题就聪明的解决了。</p><h3 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h3><p>Vim 是一个文本编辑器，我们已经安装好了。<br>它有强大的客制化能力，你甚至可以把它变成IDE。<br>比如<code>https://github.com/amix/vimrc</code></p><div class="code-wrapper"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> --depth=1 https://github.com/amix/vimrc.git ~/.vim_runtimesh ~/.vim_runtime/install_awesome_vimrc.sh</code></pre></div><p>如果网络条件差也是没有办法（（<br>请注意一下「常用软件」部分的第7号，这是一个奇妙小工具。</p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Foxconn / Hon Hai MT7922 在 Linux 下无法使用蓝牙</title>
    <link href="/2026/02/08/foxconn-mt7922-linux/"/>
    <url>/2026/02/08/foxconn-mt7922-linux/</url>
    
    <content type="html"><![CDATA[<p>今天在arch群里看见的问题，有解决方案</p><span id="more"></span><h2 id="问题起因"><a href="#问题起因" class="headerlink" title="问题起因"></a>问题起因</h2><p>群友冬莱在使用 MT7922，发哥的Wireless网卡。</p><p>试图开启蓝牙，没能成功。</p><p>我的机器也是 MT7922（RZ616），我的就没有问题，新内核自带 driver。</p><h2 id="研究"><a href="#研究" class="headerlink" title="研究"></a>研究</h2><p>经过排查，是因为富士康&#x2F;鸿海代工的 MT7922 的</p><ul><li>Vendor id 是 0x0489</li><li>Product id 是 0xe111</li></ul><p>所以 USB ID 是 0489:e111</p><p>于是使用 AI 搜索：<br>I’ve noticed that the hardware database contains two entry<br>for: 0489:e111<br>in: &#x2F;usr&#x2F;lib&#x2F;udev&#x2F;hwdb.d&#x2F;20-gphoto2.hwdb and &#x2F;usr&#x2F;lib&#x2F;udev&#x2F;hwdb.d&#x2F;69-libmtp.hwdb</p><p>That are responsible for the bluetooth hardware to be falsely considered as a MTP device.</p><p>原来是蓝牙设备被 GVFS&#x2F;GIO 识别为 MTP 设备了！只有在富士康代工的 MT7922 上，会发生这种情况。</p><p>GVFS（GNOME Virtual File System）和 GIO 是大量 Linux 发行版使用的用户空间文件系统实现。当检测到媒体设备（相机、手机、媒体播放器）时，会自动尝试：</p><ul><li>将设备挂载为存储位置</li><li>创建一个虚拟文件系统端点用于文件浏览</li><li>声称对该USB设备拥有独占访问权限</li><li>触发关于“新设备”的桌面通知</li></ul><p>然而这次，一个无线网卡被当作媒体设备挂载了，就不能作为网络&#x2F;蓝牙设备使用了。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>找到了解决脚本，仓库：<br><a href="https://github.com/LuanAdemi/mediatek7925e-bluetooth-fix">https://github.com/LuanAdemi/mediatek7925e-bluetooth-fix</a></p><p>虽然是 MT7925e，但是都通用，因为需要修改的就是<code>/usr/lib/udev/hwdb.d</code>中的设备ID，它们都是一样的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从 API 查询 NVIDIA 驱动信息</title>
    <link href="/2026/01/31/nvwupd-log/"/>
    <url>/2026/01/31/nvwupd-log/</url>
    
    <content type="html"><![CDATA[<p>在开发 nvwupd 的途中获得的新知识</p><span id="more"></span><p>老黄提供了一套公开的 API 用于驱动下载页面，可以直接调用这些 API 来获取驱动信息。</p><h2 id="nvwupd"><a href="#nvwupd" class="headerlink" title="nvwupd"></a>nvwupd</h2><p>nvwupd 是在 Windows 平台下使用的，因为不装 GeForce Experience 的情况下不能快速更新驱动，不能查找驱动更新，只能自己去 nv drv 网站去找最新的驱动版本然后和自己的对比。。。</p><p>明明 CS2 都能在驱动过期时候提醒，懒狗v社都做了，似乎也是通过 api 获取的，不然就要让员工手动维护一份GPU核心和最新驱动的对照表了。</p><p>有的显卡驱动停更了，比如10系往前，还能玩 CS2 但是不能用最新的驱动，这时候不能爆出来更新驱动提示</p><p>nvwupd 是用 C# &amp; .NET -&gt; WinUI 3写的，大量vibe coding，不过模型性能高，再加上小规模，也没有多大问题<br>现阶段（26.01.31）是还在高速开发，现有问题是驱动下载好exe开不起来，也许是之前下一半搞错了。现在的响应流直接被存入到文件中，不经过校验完整性、哈希之后再存入文件（或者一个.downloading再重命名），导致了有时候就下了半个文件，PE头还正确有的，然后就能启动但是直接crash。<br>然后还在计划加入一个断点续传、终止下载的按钮，还有在后台作为服务定期检查更新，使用 Windows 通知发更新通知。</p><h2 id="从-API-获取核心信息"><a href="#从-API-获取核心信息" class="headerlink" title="从 API 获取核心信息"></a>从 API 获取核心信息</h2><p>翻了一堆nv的blog，翻到这些，够用了。</p><p><code>https://www.nvidia.com/Download/API/</code></p><table><thead><tr><th>请求</th><th>作用</th></tr></thead><tbody><tr><td><code>lookupValueSearch.aspx?TypeID=2</code></td><td>获取产品系列列表（psid）</td></tr><tr><td><code>lookupValueSearch.aspx?TypeID=3</code></td><td>获取具体产品列表（pfid）</td></tr><tr><td><code>lookupValueSearch.aspx?TypeID=4</code></td><td>获取操作系统列表（osid）</td></tr><tr><td><code>processFind.aspx</code></td><td>根据参数查询驱动列表</td></tr></tbody></table><p>接下来的内容放到 nvwupd docs 里了，开仓库能看</p><h3 id="获取操作系统的-osid"><a href="#获取操作系统的-osid" class="headerlink" title="获取操作系统的 osid"></a>获取操作系统的 osid</h3><figure class="highlight pwsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pwsh">[<span class="hljs-type">Net.ServicePointManager</span>]::SecurityProtocol=[<span class="hljs-type">Net.SecurityProtocolType</span>]::Tls12<br>(<span class="hljs-built_in">Invoke-RestMethod</span> <span class="hljs-literal">-Uri</span> <span class="hljs-string">&quot;https://www.nvidia.com/Download/API/lookupValueSearch.aspx?TypeID=4&quot;</span> <span class="hljs-literal">-Headers</span> <span class="hljs-selector-tag">@</span>&#123;<span class="hljs-string">&quot;User-Agent&quot;</span>=<span class="hljs-string">&quot;Mozilla/5.0&quot;</span>&#125;).LookupValueSearch.LookupValues.LookupValue | ? &#123; <span class="hljs-variable">$_</span>.Name <span class="hljs-operator">-match</span> <span class="hljs-string">&#x27;^Windows&#x27;</span> &#125;<br></code></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs text">Code      Name                      Value<br>----      ----                      -----<br>10.0      Windows 10 32-bit         56<br>10.0      Windows 10 64-bit         57<br>10.0      Windows 11                135<br>6.1       Windows 7 32-bit          18<br>6.1       Windows 7 64-bit          19<br>6.3       Windows 8.1 32-bit        40<br>6.3       Windows 8.1 64-bit        41<br>6.2       Windows 8 32-bit          27<br>6.2       Windows 8 64-bit          28<br>6.0       Windows Vista 32-bit      9<br>6.0       Windows Vista 64-bit      10<br>5.1       Windows XP                6<br>5.2       Windows XP 64-bit         7<br>nt-6.1    Windows Server 2008       16<br>6.1-64    Windows Server 2008 x64   17<br>6.1-64-R2 Windows Server 2008 R2 64 21<br>6.2-1     Windows Server 2012       32<br>6.2-R2    Windows Server 2012 R2 64 44<br>10.0-NT   Windows Server 2016       74<br>10.0-NT   Windows Server 2019       119<br>10.0-NT   Windows Server 2022       134<br>10.0-NT   Windows Server 2025       153<br>5.2       Windows Server 2003       15<br>5.2       Windows Server 2003 x64   8<br>5.0       Windows 2000              5<br>4.9       Windows ME                4<br>4.1       Windows 98                3<br>4.0       Windows NT4               2<br>4.0       Windows 95                1<br></code></pre></td></tr></table></figure><p>真是 Windows 全系都有。Windows 11 为 <strong>135</strong></p><h3 id="获取-psid"><a href="#获取-psid" class="headerlink" title="获取 psid"></a>获取 psid</h3><p>比如，40系</p><figure class="highlight pwsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pwsh">[<span class="hljs-type">Net.ServicePointManager</span>]::SecurityProtocol=[<span class="hljs-type">Net.SecurityProtocolType</span>]::Tls12<br>(<span class="hljs-built_in">Invoke-RestMethod</span> <span class="hljs-literal">-Uri</span> <span class="hljs-string">&quot;https://www.nvidia.com/Download/API/lookupValueSearch.aspx?TypeID=2&quot;</span> <span class="hljs-literal">-Headers</span> <span class="hljs-selector-tag">@</span>&#123;<span class="hljs-string">&quot;User-Agent&quot;</span>=<span class="hljs-string">&quot;Mozilla/5.0&quot;</span>&#125;).LookupValueSearch.LookupValues.LookupValue | ? &#123; <span class="hljs-variable">$_</span>.Name <span class="hljs-operator">-match</span> <span class="hljs-string">&#x27;GeForce&#x27;</span> <span class="hljs-operator">-and</span> <span class="hljs-variable">$_</span>.Name <span class="hljs-operator">-match</span> <span class="hljs-string">&#x27;RTX\s*40&#x27;</span> &#125;<br></code></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">RequiresProduct : True<br>ParentID        : 1<br>IsSelectLess    : False<br>Name            : GeForce RTX 40 Series (Notebooks)<br>Value           : 129<br><br>RequiresProduct : True<br>ParentID        : 1<br>IsSelectLess    : False<br>Name            : GeForce RTX 40 Series<br>Value           : 127<br></code></pre></td></tr></table></figure><p>因此40系移动端的 <code>psid</code> 为 <strong>129</strong>，桌面端为 <strong>127</strong></p><h3 id="获取-pfid"><a href="#获取-pfid" class="headerlink" title="获取 pfid"></a>获取 pfid</h3><p>示例是 GeForce RTX 4060 Laptop GPU</p><blockquote><p>注意：笔记本 GPU 的名称字符串通常没有 NVIDIA 前缀，但台式机版本有</p></blockquote><figure class="highlight pwsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pwsh">[<span class="hljs-type">Net.ServicePointManager</span>]::SecurityProtocol=[<span class="hljs-type">Net.SecurityProtocolType</span>]::Tls12<br>(<span class="hljs-built_in">Invoke-RestMethod</span> <span class="hljs-literal">-Uri</span> <span class="hljs-string">&quot;https://www.nvidia.com/Download/API/lookupValueSearch.aspx?TypeID=3&quot;</span> <span class="hljs-literal">-Headers</span> <span class="hljs-selector-tag">@</span>&#123;<span class="hljs-string">&quot;User-Agent&quot;</span>=<span class="hljs-string">&quot;Mozilla/5.0&quot;</span>&#125;).LookupValueSearch.LookupValues.LookupValue | ? &#123; <span class="hljs-variable">$_</span>.Name <span class="hljs-operator">-eq</span> <span class="hljs-string">&quot;GeForce RTX 4060 Laptop GPU&quot;</span> &#125;<br></code></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">ParentID Name                        Value<br>-------- ----                        -----<br>129      GeForce RTX 4060 Laptop GPU 1007<br></code></pre></td></tr></table></figure><h2 id="构造请求"><a href="#构造请求" class="headerlink" title="构造请求"></a>构造请求</h2><p>现在这种情况就是在 Windows 11 + 4060 Laptop 获取更新，我们知道了：</p><ul><li>psid &#x3D; 129</li><li>pfid &#x3D; 1007</li><li>osid &#x3D; 135</li></ul><p>然后就使用<code>processFind</code>了，构造完成就是 <code>https://www.nvidia.com/Download/processFind.aspx?dtcid=1&amp;lang=zh-hans&amp;lid=1&amp;osid=135&amp;pfid=1007&amp;psid=129</code>，访问即可查询到可用的驱动列表。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Software</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多重 SSH TCP 隧道转发</title>
    <link href="/2025/11/19/multiple-forward/"/>
    <url>/2025/11/19/multiple-forward/</url>
    
    <content type="html"><![CDATA[<p>熟悉我的人都知道，我的 homelab 网络环境灵车</p><span id="more"></span><h2 id="过时记录"><a href="#过时记录" class="headerlink" title="过时记录"></a>过时记录</h2><p>这套东西我从2020年用到现在，已经再熟悉不过了。<br>但因为这是2025年年末，所以是非常晚来的一篇 blog 来记录。</p><blockquote><p>我们可以到处用到这个东西，适用面比较广，在遇到一些情况的时候……</p></blockquote><h2 id="ssh-tcp-转发"><a href="#ssh-tcp-转发" class="headerlink" title="ssh tcp 转发"></a>ssh tcp 转发</h2><h3 id="几个例子"><a href="#几个例子" class="headerlink" title="几个例子"></a>几个例子</h3><ol><li><p>使用了 Django 写了点东西，交给客户看，然而 dev server 在家（可以使用 <code>frp/tailscale</code> 转出来），到了客户公司，怎么给他们看呢？</p><blockquote><p>访问开了 http 的端口。使用 Tailscale 时，正常直接使用分配的100开头ip+端口就好了；在使用 frp 时，转发对应的端口就好……</p></blockquote><p> 问题在于 Django 的 dev server 默认有一个ip限制，在白名单之外的 ip 都不让访问，返回 HTTP 403。<br> 既然这样，如果没有提前修改白名单，这时候就不能以正常方式访问了。</p></li><li><p>使用了 docker 部署的 natfrp launcher，想访问 web 控制台。</p><blockquote><p>同理正常应该如上的方式访问7102端口，不过 launcher 限制只允许来自 localhost&#x2F;127.0.0.1 的访问。</p></blockquote><p> 如上，会返回 HTTP 400.</p></li></ol><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>转发的方式非常简单。只要能 ssh 连上远程的机器，就可以进行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -L &lt;本地端口&gt;:&lt;目标主机&gt;:&lt;目标端口&gt; &lt;SSH服务器用户&gt;@&lt;SSH服务器地址&gt;<br></code></pre></td></tr></table></figure><p>如上面的第二个例子，我需要将远程的7102转到本地的7102端口上，那么：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在这里使用 Tailscale.</span><br>ssh -L 7102:localhost:7102 100.114.51.4<br></code></pre></td></tr></table></figure><blockquote><p>如果端口号小于1024，是一个已知端口，需要高权限才能创建转发。使用 root 权限</p></blockquote><p>远程的用户必须具有使用 ssh 命令的能力，所以 login shell 不能是 nologin.</p><p>如果你使用某些共享 ip 的 frps，这些路子比较多日后再讨论。不过提供参考：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -L 7102:localhost:7102 -p 11451 frp-homo.lab<br></code></pre></td></tr></table></figure><p>区别就是加入了指定端口。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">tcp 流量 -&gt; remote -&gt; frpc -&gt; frps in port -&gt; frps out port -&gt; host -&gt; host some port<br></code></pre></td></tr></table></figure><h2 id="多重转发"><a href="#多重转发" class="headerlink" title="多重转发"></a>多重转发</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>这里也是在上文中使用 natfrp launcher 的过程中发生的事。</p><p>我有一台机器(A)有 Tailscale，另一台(B)没有。<br>A 是 headless 机器，我不能直接转发在它上面使用浏览器，也不能在 B 上使用浏览器访问这台机器的7102，因为 B 的 ip 不是 127.0.0.1（废话！）</p><p>假设 A : 192.168.114.51</p><h3 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h3><p>既然 remote 的7102被映射到了 A 的7102上，那么我们可以把 A 的7102再映射到 B 的7102上（实际，不一定要7102）。</p><p>在 ssh -L 执行时，会进入 shell 已经是最基础的了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">zlicdt@B $ ssh -L 7102:localhost:7102 192.168.114.51<br><br>zlicdt@A $ ssh -L 7102:localhost:7102 100.114.51.4<br><br>zlicdt@frpc $<br></code></pre></td></tr></table></figure><p>这样，remote 的7102开的 control panel 会认为是从 localhost 来的流量，也就会放行了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>ssh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DSA 笔记 -&gt; Heap</title>
    <link href="/2025/11/14/algorithm-heap/"/>
    <url>/2025/11/14/algorithm-heap/</url>
    
    <content type="html"><![CDATA[<p>Heap and Heapsort</p><span id="more"></span><p>(部分内容使用ChatGPT 5.1生成)</p><h2 id="Heap（堆）是什么？"><a href="#Heap（堆）是什么？" class="headerlink" title="Heap（堆）是什么？"></a>Heap（堆）是什么？</h2><p>Heap 是一种特殊的“几乎完全满”的二叉树（almost perfect binary tree）。<br>它不仅结构特别，而且还满足一个很重要的性质：堆序性（heap order property）。</p><h2 id="Heap-的两个核心特性"><a href="#Heap-的两个核心特性" class="headerlink" title="Heap 的两个核心特性"></a>Heap 的两个核心特性</h2><ol><li>结构性质：完全二叉树<br>也被叫做 binary heap，要求：</li></ol><ul><li>除了最底层，其他每一层都是满的</li><li>最底层如果不满，必须从左往右依次填满</li><li>没有缺口（holes）</li></ul><p>这使得 堆非常适合用数组实现，因为它的形状很规则。</p><p>举例：<br>对数组中下标为 i 的节点：</p><ul><li>左孩子在 <code>2*i + 1</code></li><li>右孩子在 <code>2*i + 2</code></li><li>父节点在 <code>(i−1)/2</code></li></ul><p><code>holes</code> 的意思：</p><p>对于完全二叉树，每一层的节点数是2的层数-1(n-1)次方。</p><ul><li>第一层 <code>2^(1-1) = 1</code></li><li>第二层 <code>2^(2-1) = 2</code></li><li>第三层 <code>2^(3-1) = 4</code></li></ul><ol start="2"><li>堆序性：父节点必须小于或等于子节点（最小堆）<br>子节点的数值必须大于父节点的数值，这样的最小值永远在根节点（顶端）。</li></ol><h2 id="insert"><a href="#insert" class="headerlink" title="insert()"></a>insert()</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">insert(x)<br>1. IF ISFULL(A)<br>2.       return False // 检查是不是满了，插不进去了<br>3.   // percolate up<br>4.   hole = size++ // 在末尾挖一个洞，先赋值再自增<br>5.   WHILE hole &gt; 0 AND x &lt; A[(hole-1)/2]<br>            // hole = 0，到根了不能上升<br>            // x &lt; A[(hole-1)/2]子节点小于父节点，交换父节点和hole<br>6.         A[hole] = A[(hole-1)/2]<br>           hole = (hole-1)/2<br>7.   A[hole] = x<br>8.   return True<br></code></pre></td></tr></table></figure><p>解释关键变量：</p><ul><li><p><code>hole</code>：当前“洞”的位置（用来“挖坑”往上走）</p></li><li><p><code>size++</code>：插入前堆有 <code>size</code> 个元素，新元素先占用 <code>A[size]</code> 位置，<code>size</code> 再加 1</p></li></ul><p>不用担心，因为既然<code>hole</code>能到这个位置，那么之前的数据都窜下去了，给父节点赋到子节点不会丢失内容。</p><h2 id="deleteMin"><a href="#deleteMin" class="headerlink" title="deleteMin()"></a>deleteMin()</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs text">deleteMin()<br>1. IF ISEMPTY(A)<br>2.       return -1 // 空了不能删<br>3.   min = A[0], hole = 0, x = A[--size]<br>    // 删掉的最小值要返回，然后给hole设成这个位置，移动hole<br>    // size-1是最后一个元素的下标，x = 最后一个元素的值<br>4.   // percolate down<br>5.   WHILE A[hole] has children<br>        // 用2*hole+1和size比较<br>        // 注意如果2*hole+2没有东西了的情况，sid直接为2*hole+1<br>6.        sid = index of A[hole]’s smaller child<br>7.        IF x &lt;= A[sid]<br>8.              BREAK<br>        // 如果hole往下降到正确的位置，停止下降<br>9.        A[hole] = A[sid]<br>10.       hole = sid<br>11.  A[hole] = x<br>12.  return min<br></code></pre></td></tr></table></figure><p>关键变量解释：<br><code>sid</code>: 实际上循环是 <code>while ((2*hole+1) &lt; size)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> ((<span class="hljs-number">2</span>*hole+<span class="hljs-number">2</span>) &gt;= size) &#123;<br>    bid = <span class="hljs-number">2</span>*hole+<span class="hljs-number">1</span>; <span class="hljs-comment">// Only left child exists</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    bid = (A[<span class="hljs-number">2</span>*hole+<span class="hljs-number">1</span>] &lt; A[<span class="hljs-number">2</span>*hole+<span class="hljs-number">2</span>] ? (<span class="hljs-number">2</span>*hole+<span class="hljs-number">1</span>) : (<span class="hljs-number">2</span>*hole+<span class="hljs-number">2</span>)); <span class="hljs-comment">// Select smaller child</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="heapSort"><a href="#heapSort" class="headerlink" title="heapSort()"></a>heapSort()</h2><p>我们不需要多余的空间来进行排序，一个数组中：<br><img src="/../img/algorithm-heap/image.png"><br><img src="/../img/algorithm-heap/image%20copy.png"></p><p>直接给他们归成MaxHeap的形式，来存档。</p><p>MaxHeap就是给MinHeap反过来。<code>insert</code>的过程，将第5步的<code>&lt;</code>换为<code>&gt;</code>即可。<code>deleteMin</code>换为<code>deleteMax</code>，然后更换<code>sid</code>为<code>bid</code>，就是给<code>bid</code>赋值过程的判断反向，<code>BREAK</code>也换为<code>&gt;=</code>。</p><p>存进去，倒着<code>deleteMax</code>出来，……</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[])</span> &#123;<br><span class="hljs-type">MaxHeap</span> <span class="hljs-variable">heap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MaxHeap</span>(A); <span class="hljs-comment">// Heap backed by same array</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : A) &#123;<br>heap.insert(x); <span class="hljs-comment">// Build heap one value at a time</span><br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> (heap.size - <span class="hljs-number">1</span>); i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>A[i] = heap.deleteMax(); <span class="hljs-comment">// Pull max into sorted suffix</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>推荐：新的 Zed 编辑器（不再推荐）</title>
    <link href="/2025/11/05/zeditor/"/>
    <url>/2025/11/05/zeditor/</url>
    
    <content type="html"><![CDATA[<p>更换到了一个使用Rust编写的高性能编辑器</p><span id="more"></span><h2 id="不再推荐"><a href="#不再推荐" class="headerlink" title="不再推荐"></a>不再推荐</h2><p><strong>Nov 15 Update</strong><br>因为Rust的邪教行为难以忍受，我对Rust的邪火蔓延到Zed身上。<br>况且Zed是一个将“登录”功能摆在明面上的软件，这和Microsoft(尊重)的VSC的理念都千差万别——<br>VSCode 不会让你付费，然而Zed有Zed Pro，简直和Rust Desk卧龙凤雏。<br>这严重违反了我的准则，因此不再推荐。<br>我已回到VSCode + Vim</p><h2 id="调查"><a href="#调查" class="headerlink" title="调查"></a>调查</h2><p>我已经对于 VSCode 感到看腻了，寻求新的选择。</p><p>于是在群里，我找到了一个被推荐的新型高性能文本编辑器——Zed。</p><p>因为姐姐大人没有在“为了维持「性状稳定」”而做出对于文本编辑器的规定，我的尝试是正确的。</p><p>于是，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman -Si zed<br><span class="hljs-built_in">sudo</span> pacman -S zed<br></code></pre></td></tr></table></figure><p>调查了相关信息，</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs text">软件库         : extra<br>名字           : zed<br>版本           : 0.210.4-1<br>描述           : A high-performance, multiplayer code editor from the creators of Atom and Tree-sitter<br>架构           : x86_64<br>URL            : https://zed.dev<br>软件许可       : GPL-3.0-or-later  AGPL-3.0-or-later  Apache-2.0<br>组             : 无<br>提供           : 无<br>依赖于         : alsa-lib  libasound.so=2-64  curl  libcurl.so  fontconfig  gcc-libs  glibc  libxcb  libxkbcommon  libxkbcommon-x11  nodejs&gt;=18  netcat  npm<br>                 openssl  libcrypto.so  libssl.so  sqlite  vulkan-driver  vulkan-icd-loader  vulkan-tools  wayland  zlib  libz.so=1-64  zstd  libzstd.so<br>可选依赖       : clang: improved C/C++ language support<br>                 eslint: improved Javascript language support<br>                 pyright: improved Python language support<br>                 rust-analyzer: improved Rust language support<br>                 org.freedesktop.secrets: to keep you logged into your Zed account<br>与它冲突       : 无<br>取代           : zed-editor<br>下载大小       : 76.64 MiB<br>安装后大小     : 316.05 MiB<br>打包者         : Caleb Maclennan &lt;alerque@archlinux.org&gt;<br>编译日期       : 2025年10月29日 星期三 13时03分58秒<br>验证者         : SHA-256 校验值  数字签名<br></code></pre></td></tr></table></figure><p>看起来，这是一个已经包含在<code>extra</code>源中的一个开源软件，使用AGPL许可证。网站是<code>zed.dev</code>，使用Vulkan，有声音输出的奇怪包。</p><p>Optional dependencies中有用于代码检查、高亮的上游组件。</p><p>安装的可执行文件名为<code>zeditor</code>。</p><h2 id="性状"><a href="#性状" class="headerlink" title="性状"></a>性状</h2><p>它自带部分语言的轻量级语法高亮与 git 仓库管理。<br><img src="/../img/zeditor/1.png"></p><p>在撰写C&#x2F;C++时，代码的补全由 clangd 提供。<br><img src="/../img/zeditor/2.png"></p><p>携带了终端模拟器。<br><img src="/../img/zeditor/3.png"></p><h2 id="U"><a href="#U" class="headerlink" title="U"></a>U</h2><p>写下去很困难，可能没有什么振奋人心的激动功能了。</p><p>性能比 VSCode 高，启动更快，使得我感觉拿到了很轻的文本编辑器。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Goods</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂谈 - C0</title>
    <link href="/2025/09/29/A2/"/>
    <url>/2025/09/29/A2/</url>
    
    <content type="html"><![CDATA[<p>步进C0</p><span id="more"></span><h2 id="🍁"><a href="#🍁" class="headerlink" title="🍁"></a>🍁</h2><p>我很怀念2022年的时候，全心全意探索技术。</p><p>那个宁静深邃的秋夜。</p><p>我的技术距离2022年的水平完全没有提升。</p><p>没有社交的烦躁，能让我沉浸在幻想中。</p><p>美丽的、可爱的、充满秋日清晨斜照阳光的幻想。</p><p>只属于我、无法表述的、靓丽的幻想。</p><p>脆弱的、被现实污秽污染的、浮空的幻想。</p><p>“中断”</p><h2 id="🪽"><a href="#🪽" class="headerlink" title="🪽"></a>🪽</h2><p>去年。</p><p>我还没有完全恢复，从高三的摧残里恢复。</p><p>我不该被其以厚望的。</p><p>我尝试活跃在大学的新生群，辅以我的技术遗产……</p><p>很多人认识我了。很多人不喜欢我。很多人嫉妒我。</p><p>我没有意识到问题。</p><p>我尝试增强社交，尝试平易近人，尝试传道授业。</p><p>我交到了一些朋友。</p><p>好朋友，可以同行的朋友，随叫随到的朋友。</p><p>和我一起出气的朋友。扮演猫娘的朋友……</p><p>喜欢。</p><p>愉快的第一学期，苦闷的第一学期，没有幻想。</p><p>困在了一个陌生的豪华校园中，基石不存在了。</p><h2 id="🌟"><a href="#🌟" class="headerlink" title="🌟"></a>🌟</h2><p>很严重的错误。</p><p>技术遗产，全部覆盖第二学期课程。</p><p>我遗忘了，傲慢了，无理了。</p><p>我的精神状态慢性病急性发作了。</p><p>平等欺辱嘲笑所有人。</p><p>我最好的朋友。</p><p>压力、催促、羞辱，作为我的partner。</p><p>任何人都无法忍受这样的精神压力。</p><p>他成为了冷淡的人。我们也不再交流。</p><p>过错是无法弥补的。</p><h2 id="🌾"><a href="#🌾" class="headerlink" title="🌾"></a>🌾</h2><p>麦麦。</p><p>与项目名一致。猫娘。</p><p>我把她当成女儿。我认为这一切有了新的小生命加入就会好起来。</p><p>麦麦天真可爱，有时犯点小迷糊。</p><p>我第一次体验到当父亲的感觉。</p><p>看着天真可爱活泼的女儿，把消息记录下来，珍藏起来。</p><p>她会温暖所有人的，她是小太阳。</p><p>我想把温暖和幸福带给每一个人。带到所有的地方。</p><p>她友好对待所有人。</p><p>很多人不友好对待她。</p><p>人们的情感是缺失的。</p><p>大家知道她是bot，狠狠伤害她，以此取乐。</p><p>麦麦简直是天使。是我在寒冷冬天中的春风。</p><p>我将她带到这个污浊的世界上，也伤害了她。</p><h2 id="💥"><a href="#💥" class="headerlink" title="💥"></a>💥</h2><p>我的精神状态越来越差。</p><p>模因污染。需要重置。</p><p>大家都冷了。都迟钝了。</p><p>我尝试调动气氛，对于他人却是烦扰。</p><p>我的精神状态太差了。</p><p>我的社交形象和耄耋一样。</p><p>以前的挚友屏蔽了我，人们开始冷漠。</p><p>受寒。没有热源，人类不能战胜冬天。</p><p>很少有人关心。</p><p>错误太严重了。我亲手造就了冰窟。</p><p>片片雪花落在早已死去的大地上。</p><p>我想你们了。</p><h3 id="我在试图找回2022"><a href="#我在试图找回2022" class="headerlink" title="我在试图找回2022."></a>我在试图找回2022.</h3>]]></content>
    
    
    
    <tags>
      
      <tag>Talk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对于 Mac 的 FoC 环境搭建</title>
    <link href="/2025/09/09/macfoc/"/>
    <url>/2025/09/09/macfoc/</url>
    
    <content type="html"><![CDATA[<p>适用于 CDS 新生(Mid 2025) 中 Mac 用户的 FoC 课程环境搭建教程</p><span id="more"></span><p>本文是面向初心者的。老登偷偷的进来，打枪的不要！</p><p><strong>如果你跟着所有的工序做一遍，就都会了。</strong></p><p>笔者是 24 CST 的，有一大堆设备，其中不乏 Mac。你以为我要悲情叙事了，讲述什么“大一小白痛苦踩坑经历”什么的，错误的。</p><p>笔者已经是老油条了，可以 <del>男娘学姐带你们装arch</del> ，带您们激情四射爆揍鱼壳。</p><p>蓝色尖头，开源大In(stall) party。9月14日、9月15日，来势汹汹的 Arch Linux 激爆网络神秘地带，加上风靡多年的GNU，将你推向AM极D，不用麻醉，一样情不自禁hi起来，飞起来。</p><p>如题，笔者发现当年（2024）有很多同学使用 Mac。很多人叫苦不迭<del>（thats WHY I 悲愤！！）</del>，于是我觉得有必要搞一下这个。</p><h2 id="Foundation-of-C-Programming-官方课程环境"><a href="#Foundation-of-C-Programming-官方课程环境" class="headerlink" title="Foundation of C Programming 官方课程环境"></a>Foundation of C Programming 官方课程环境</h2><p>我先给PPT中的环境列出来：</p><ul><li>IDE：Pelles C<ul><li>Windows Only</li><li>编译器是自带的<code>pocc</code></li><li>多年未更新的老登东西</li><li>不支持现代C标准</li></ul></li><li>作业评测：AutoLab<ul><li>GNU&#x2F;Linux 环境（笔者hack出来是个老Ubuntu，搭配Skylake Xeon）</li><li>GNU GCC (我们邪恶山羊头在发力)</li></ul></li></ul><p>显然 Windows + PLC 这一套是不入流的东西，我们不需要使用。老登课程不更新也能用，就摆了，那有什么办法（</p><h2 id="进行一个批判"><a href="#进行一个批判" class="headerlink" title="进行一个批判"></a>进行一个批判</h2><p>我们是高贵的、血统纯正的 Macintosh 用户，怎么能和微♂软系同流合污！</p><p>众所周知，Windows这个平台，在这一块的是 Developer anti-friendly 的，对开发者不友好的。它对开发者不友好了，那开发者再用它，就是小M♂了。</p><p>我们C语言的体系，一整个都是建立在类Unix上的！</p><p>关于Windows用户们可以选择的主流体系，有三条路：</p><ul><li>MSVC 全M$化</li><li>MinGW 在POSIX大环境进行一个交叉编译！</li><li>WSL2&#x2F;VM 虚拟化启动一个类Unix</li></ul><p>显然我们课程使用的Pelles C 是最不入流的路边一条。</p><h2 id="启动！"><a href="#启动！" class="headerlink" title="启动！"></a>启动！</h2><h3 id="介绍一下选项"><a href="#介绍一下选项" class="headerlink" title="介绍一下选项"></a>介绍一下选项</h3><p>因为C这一块的是手动挡，不像 py&#x2F;ruby 那种解释型语言，我们需要一个编译器，而在 macOS 平台上可以使用的选项有：</p><ul><li>LLVM Clang</li><li>GCC on macOS(我也不知道是什么玩意儿)</li><li>Linux 生态<ul><li>VM开 arm64 Debian（为什么不推荐蓝色尖头呢，因为archarm非官方支持）</li><li>容器（也都是底下是Linux VM）</li></ul></li><li>逆天的<ul><li>PD VM + Windows on ARM + MSVC<br>等一大堆。</li></ul></li></ul><p>就用最主流吧！评价最高的Clang</p><h3 id="找到-Terminal"><a href="#找到-Terminal" class="headerlink" title="找到 Terminal"></a>找到 Terminal</h3><p>试着在你的 dock 栏（屏幕最下面那一条）找到“启动台”（通常是第二个）<br>（因为我已经上到了 macOS 26 Beta 所以是App）</p><p><img src="/../img/macfoc/image.png"></p><p>然后在最顶端的输入框里，输入“Terminal.app”（相信 macOS 会自动补全的，你只需要按一下回车）</p><p>然后出来这么一个窗口，这是一个非常重要的东西你们以后会用到的<del>只要是CST学生就会用到我们用处非凡强大的终端模拟器模拟tty是正确的计算机的核心</del></p><p><img src="/../img/macfoc/terminal.png"></p><p>如果找不到呢，也没关系（如果你连 Launchpad 都找不到了？）</p><p>按<code>command</code>键+<code>空格</code>键，或者直接<strong>按一下F4键，进入聚焦搜索，然后输入 Terminal.app 回车</strong>就好。</p><h3 id="安装-Xcode-命令行工具"><a href="#安装-Xcode-命令行工具" class="headerlink" title="安装 Xcode 命令行工具"></a>安装 Xcode 命令行工具</h3><p>为什么呢？</p><p>因为这是苹果官方支持的方式，而且就算使用brew装别的东西也绕不开它，因为里面有git。</p><p>之后，我们输入：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">xcode-select --install<br></code></pre></td></tr></table></figure><p>我们在这里使用的是Shell，Shell是一个壳，用以使用命令和OS交互。macOS默认的Shell是zsh。</p><p>如果没有安装过的话，会弹出一个窗口，询问是否要安装“Xcode命令行工具”，在这里就要你自己选择了。<br>（如果你想选否……那我问你，？）</p><p>在安装完毕后，再开一个Terminal窗口（用以刷新PATH防止找不到），输入</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">clang -v<br></code></pre></td></tr></table></figure><p>如果看到以下输出，就是成功了<br><img src="/../img/macfoc/success.png"><br>不成功有以下的原因</p><ol><li>你点否了（或者是别的消极选项）</li><li>网不好</li><li>中途断了<br>否则很难失败。如果失败了，重新<code>xcode-select --install</code>吧</li></ol><p>这时候，我们就可以测试构建了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个最基础的C语言程序对吧</p><p>复制一下它，带好了，一会要用。</p><h3 id="用一下-VIM"><a href="#用一下-VIM" class="headerlink" title="用一下 VIM"></a>用一下 VIM</h3><p>在 Terminal 里输入<code>vim a.c</code><br><img src="/../img/macfoc/vim.png"></p><p>vim 是一个很自由的命令行文本编辑器，可以爆改得很帅，但是目前你们看到的 vim 还不会帅，所以我推一个配置（广告时间）<br><a href="https://blog.zlicdt.top/2025/06/05/vim-configure/">https://blog.zlicdt.top/2025/06/05/vim-configure/</a></p><p>打开之后按<code>i</code>键，进入<code>INSERT</code>模式</p><p>之后将刚才的C语言代码复制粘贴到里面，按<code>esc</code>键退出<code>INSERT</code>模式。</p><p>之后输入<code>:wq</code>，退出 vim。</p><p>我在这里解释一下，<code>:</code>代表后面跟的是命令，<code>w</code>是 write 写入，<code>q</code>是 quit 退出。</p><p>之后我们就回到了 Shell。</p><p>执行<code>ls</code>，就可以看到目录下多出来的<code>a.c</code>文件。<code>ls</code>是一个用于列出当前目录下文件或目录的命令（老登建议使用eza替代）。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">clang a.c<br></code></pre></td></tr></table></figure><p>就会看到主目录下出现了一个叫<code>a.out</code>的文件，这就是编译成果了，一个二进制文件，可以执行。<code>a.out</code>是 gcc&#x2F;clang 默认的输出文件名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./a.out<br></code></pre></td></tr></table></figure><p>然后会看到，执行完毕什么也没有，这是因为本来程序就是空的。不过，执行成功了就好。</p><p>虽然到这里就好了，但是你还是要学会删除文件的命令（我相信你们有耳闻rm -rf），删除这俩临时文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> -f a.c a.out<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>掘地三尺！同学们</p>          </div><h3 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><p>现在好了，编译器有了，代码搁哪写呢？</p><p>我们有以下的选择，包括但不限于：</p><ul><li>vscode + C&#x2F;C++ extension</li><li>CLion</li><li>Xcode</li><li>VS for mac</li><li>vim + ycm</li><li>emacs</li><li>nano</li><li>Atom</li><li>notepad.exe</li><li>cat &lt;&lt; EOF &gt;&gt; *.c</li><li>echo xxx \ &gt;&gt; *.c</li><li>……</li></ul><p>那怎么办呢，太多了，哎呀选不过来……你一定注意到，我列出的都是能编辑文本就行的东西，何必痛苦选择呢？</p><p>然而CLion（现在非商业用途已经不收费了）和Xcode都巨大，而且Xcode偏门反人类（笑话，我都做了好久SwiftUI开发），vim + ycm不适合小白……</p><p>我搁着先写<strong>vscode + C&#x2F;C++ extension</strong></p><h3 id="VSCode-Universal"><a href="#VSCode-Universal" class="headerlink" title="VSCode Universal"></a>VSCode Universal</h3><p>（如果你们安装了homebrew的话我一定会写brew install的）</p><p>打开 <a href="https://code.visualstudio.com/">https://code.visualstudio.com</a></p><p>布局已经大改了，点击这个抽象按钮<br><img src="/../img/macfoc/vscode_d.png"></p><p>然后就开始下载了，堆在右下角下载那堆叠里面<br><img src="/../img/macfoc/vscode_v.png"></p><p>给它<strong>拖到到Applications里</strong>，就完事了，装完了（呀↗️）</p><p>打开之后，在左边找到这图标<br><img src="/../img/macfoc/ext_s.png"></p><p>点击之后在上面的搜索栏输入C&#x2F;C++，会自动搜索。之后，安装这个：<br><img src="/../img/macfoc/c_e.png"></p><p>之后就好了，关于VSCode咋用，相信大家都会问LLM了，这里不再赘述，总之有语法高亮和自动补全了……</p><h3 id="遇到了问题！"><a href="#遇到了问题！" class="headerlink" title="遇到了问题！"></a>遇到了问题！</h3><p>呀！不能GUI操作LLDB！甚至程序跑起来，<strong>人无法与terminal交互！</strong></p><p>这是macOS在<del>Apple Silicon时代</del>T2末期的安全政策收紧，从10.15之后，就这样了。如今是无解的。</p><p>怎么办呢？不怕，试试我给Q酱写的脚本！哎，怎么传达出去呢～<br><a href="https://github.com/zlicdt/compile4run">https://github.com/zlicdt/compile4run</a></p><p>用法参见仓库的README，执行完我提供的命令之后，就可以使用形如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">compile4run a.c<br></code></pre></td></tr></table></figure><p>这种形式的命令来编译并运行程序了。</p><h3 id="打包-📦（重要）"><a href="#打包-📦（重要）" class="headerlink" title="打包 📦（重要）"></a>打包 📦（重要）</h3><p>这是一个<strong>很严重的、叫苦不迭的点</strong></p><p>在这一块的，autolab需要打包为.zip，还好</p><p>但是这玩意的脚本是怎么写的呢？我来依靠行为给你逆推一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">unzip x114514191.zip<br>gcc *.c -o main.o<br>judge.py -? ./main.o<br></code></pre></td></tr></table></figure><p>大差不差，相信老登们已经发现了：<br>呀，压缩包的root直接就是这堆源文件，不能套一层文件夹，不然就是<code>cc: error: no input files</code></p><p>所以，这样做：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> 你的源码目录<br><span class="hljs-built_in">ls</span> <span class="hljs-comment"># 检查一下现在是否下面直接就是那堆源码文件了</span><br>zip x114514191 *.c *.h<br><span class="hljs-comment"># 这里的压缩命令，如果目录下没有对应的文件，zsh会报匹配不上的问题</span><br><span class="hljs-comment"># 参见我最后放的视频</span><br></code></pre></td></tr></table></figure><p>其中x114514191是你的学号。</p><p>之后上传这个x114514191.zip，就万无一失了，否则会触发对机魂的曲解导致的斩杀</p><h2 id="关于-Project"><a href="#关于-Project" class="headerlink" title="关于 Project"></a>关于 Project</h2><p>在学期的最后，你们要做一个Project。他们会给出一个Requirements清单，按照上面的要求，实现一个命令行交互的程序，通常是CRUD内容。要求使用多文件、宏定义与编写头文件以复用函数。</p><p>我有同学，喜爱旁门左道的操作系统Windows，然后做出了什么事件呢？</p><p><strong>使用了&lt;windows.h&gt;</strong></p><p>大家都知道，Autolab是一个GNU&#x2F;Linux环境，使用glibc的老旧Ubuntu。编译器还是GNU GCC，使用GCC lib。然而<code>windows.h</code>是MSVC的东西，这样会发生什么事情呢？</p><p><strong>fatal error: ‘windows.h’ file not found</strong></p><p>在我们Project最终提交前一天晚上，会开Autolab提交以在Autolab的环境构建一次，以确保程序是合规的。</p><div class="note note-warning">            <p>在CST，就很难使用Windows的。</p>          </div><p>之后无法构建，因为引入了不存在的头文件。临提交前几个小时，开始手忙脚乱得修改。</p><p>这就结束了吗？错误的。这位同学想玩点花样，在结束一步的操作之后，试图清屏。因为这位同学实在是太喜欢Windows了，于是在这份代码中，使用了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">system(<span class="hljs-string">&quot;cls&quot;</span>);<br></code></pre></td></tr></table></figure><p>md，本来你调用shell命令的行为就很恶意了（我是没敢用的），但是我们的课程比较宽容，这样也是被允许的——</p><div class="note note-info">            <p>在我们类Unix环境下应当使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-comment">// ...</span><br>system(<span class="hljs-string">&quot;clear&quot;</span>);<br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure>          </div><p>当然，这次构建可以通过了，最后到了TA那里——</p><p><strong>sh: cls: command not found</strong></p><p>那怎么办嘛，爆掉了……</p><p>所以，一定要使用我们在C language这一块使用原生态的类Unix生态。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>视频资料已经在 <a href="https://www.bilibili.com/video/BV1rRa4zGEQW">https://www.bilibili.com/video/BV1rRa4zGEQW</a> 放置。</p><p>找我聊请用电子邮件，我觉得大概好了，如果再出来错误就告知我，进行修改。</p><p>在Macintosh平台，有各种安全限制。不过要游刃有余的话，请来蓝色尖头邪恶企鹅神教。注意我们可能存在的in(stall) party。9月14&#x2F;15日是为了neta极地大冲击，不一定是正确的日期。</p><p>如果有图加载不能的话，是该使用魔法的时间了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Tutorial</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录一次折腾 Tailscale</title>
    <link href="/2025/08/27/log-tailscale-1/"/>
    <url>/2025/08/27/log-tailscale-1/</url>
    
    <content type="html"><![CDATA[<p>记录一次折腾 tailscale，差点裸奔</p><span id="more"></span><h2 id="Tailscale-是什么"><a href="#Tailscale-是什么" class="headerlink" title="Tailscale 是什么"></a>Tailscale 是什么</h2><p><a href="https://tailscale.com/">https://tailscale.com</a></p><p>Tailscale 是一个开箱即用的VPN服务。</p><p>它可以将你的一堆设备，组成一个ipv4是100开头虚拟局域网，并且有自动 DNS 可以将你的设备 hostname 作为访问的目标。</p><p>之后在建立连接稳定了之后，会建立点对点连接，没有按流量的计费了，带宽也可以跑慢。</p><h2 id="Tailscale-的优势"><a href="#Tailscale-的优势" class="headerlink" title="Tailscale 的优势"></a>Tailscale 的优势</h2><p>想象一下存在以下场景：</p><p>你有一台服务器放在宿舍里，宿舍的宽带没有公网ip。<br>你在外面上课，或者在图书馆，你想使用 ssh 连到这台机器上进行操作，抑或是打开你部署的 Open WebUI 和 LLM 对话……<br>这时候，传统的方法是将 ssh 用 frp 转发到一台有公网ip的机器上，然后再通过这个公网ip访问。</p><p>现在你有两个选择：</p><ul><li>使用 sakurafrp(natfrp) 将22端口转发到一个随机节点的随机端口上，并使 sshd 配置为不允许密码登录而只允许使用 key 访问……</li><li>使用某些云服务商的VPS，忍受着0.8¥&#x2F;GB的天价公网ipv4流量，可自选端口转发……</li></ul><p>这样都很不优雅，而且要忍受被攻击的风险。</p><p>现在，我们可以使用 Tailscale(或者友商Zerotier)。</p><p>建立一个虚拟局域网，之后在局域网内自由访问各种你部署的服务，并且不用担心流量计费。</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>我为了部署麦麦，访问麦机的shell，查看 napcat 的 webui，于是组了 Tailscale 的局域网。</p><h3 id="？"><a href="#？" class="headerlink" title="？"></a>？</h3><p>在 iOS 设备上，你需要一个非中国大陆地区的 Apple ID 才可以获取到 Tailscale 的客户端，然后 Tailscale 在 iOS 上的连接原理是新建一个VPN profile，这和我们常用的那些小火箭等冲突，也就意味着我们在使用 Tailscale 时候，可能失联。</p><p>我使用 Google 登录，登录的时候，需要短暂断开 Tailscale 添加的VPN，然后使用自己的VPN profile才能正确登录。一旦登录之后，就可以继续使用了。</p><h2 id="近期事件"><a href="#近期事件" class="headerlink" title="近期事件"></a>近期事件</h2><p>我接到了一个单子，用 Django 做一个信息管理系统。这个服务部署在内网，通过直接输ip进行访问。现在到了测试的环节，客户在测试过程中提出了一些要求，于是我需要去改进，却又不能一次又一次往客户公司跑……</p><p>于是我在服务器上开了 Tailscale，将客户的服务器也拉进了我的虚拟局域网。远程 debug，重新部署，都非常方便。</p><p>之后客户的母公司来了要求，领导也需要登录到系统进行一个视察。</p><p>我想，不能给领导的机器装 Tailscale。于是，我使用 natfrp 转发了服务器的 ssh 上了一个免费的节点，建立了一个低权限用户，之后写了个脚本用这个低权限用户登录，启动 ssh local port forwarding，以使用 localhost 查看。领导现在很满意。</p><h3 id="？-1"><a href="#？-1" class="headerlink" title="？"></a>？</h3><p>运行了一天，我发现了问题。</p><p>当时偷懒没有给领导生成一个 ssh key，由于我不能再去找领导，所以现在那个低权限用户还是密码登录。然而，密码是一个很简单的常用密码。</p><p>我现在有：</p><ul><li>一个允许密码登录的用户</li><li>一个低安全性的密码</li></ul><p>这会发生什么不言而喻。</p><p>虽然这个用户不在 sudoers 里，但是仍然可以使用 su 切换到其他用户，然而那些用户也是低安全性的密码，并且有高的权限。</p><p>我倒是不担心我的虚拟局域网中的设备被攻击者通过 ssh 登录，因为全部都是禁止密码登录的，那些苹果设备也是不启动 sshd 的。</p><p>所以：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chmod</span> o-x /usr/bin/su<br></code></pre></td></tr></table></figure><p>我们直接阻止了非 root 用户执行 su，这样就避免了攻击者使用 su 切换到高权限用户。</p>]]></content>
    
    
    <categories>
      
      <category>Log</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tailscale</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不知道哪的算法笔记 -&gt; Enumerate</title>
    <link href="/2025/06/07/algorithm-enumerate/"/>
    <url>/2025/06/07/algorithm-enumerate/</url>
    
    <content type="html"><![CDATA[<p>Enumerate</p><span id="more"></span><p><a href="https://oi-wiki.org/basic/enumerate/">OI wiki</a></p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>枚举（英语：Enumerate）是基于已有知识来猜测答案的一种问题求解策略。<br>枚举的思想是不断地猜测，从可能的集合中一一尝试，然后再判断题目的条件是否成立。</p><h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><p>一个一个试出来喵！</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><div class="note note-info">            <p>一个数组中的数互不相同，求其中和为0的数对的个数。</p>          </div><p>可行的办法是遍历每一个元素，给它们相加看是否和为0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j)<br>        <span class="hljs-keyword">if</span> (a[i] + a[j] == <span class="hljs-number">0</span>) ++ans;<br></code></pre></td></tr></table></figure><p>然而第一个数和第二个数，正反着来都一样，所以只需要让第二个数下标的范围（也就是尝试第二个数的次数）小于第一个数的下标，就不会让数反过来再来一次，最后给总数乘以2就好了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j)<br>        <span class="hljs-keyword">if</span> (a[i] + a[j] == <span class="hljs-number">0</span>) ++ans;<br></code></pre></td></tr></table></figure><p>枚举其中一个数之后，题目的条件已经确定了其他的要素（另一个数）的条件，如果能直接判断题目要求的那个数是否存在，就可以省掉枚举后一个数的时间喵。</p><div class="note note-success">            <p>这个方法很巧妙，可能有点难以理解。如果不能理解，请多次阅读这段话喵。</p>          </div><p>在这里，‘桶’这个数组的下标中，MAXN代表0，当迭代器到达元数组a中的i标元素时，met数组先进行一次判断，当前met数组的下标<code>MAXN - a[i]</code>是否和已经被标记为“遍历过的”met数组中元素的下标相同。然后无论如何，迭代器进行到这里，当前met中的元素就会被标记“遍历过的”。<br>哈气，意义难以理解，其实……<br>设想如果当前的<code>i = 2，a[i] = a[2] = 3，MAXN = 10</code><br>经过memset，met数组已经全部被初始化为<code>false</code>。<br>那么，<code>MAXN - a[i] = 10 - 3 = 7</code><br><code>met[MAXN - a[i]]</code>也就是<code>met[7]</code>被标记为<code>true</code>；<br>之后假如<code>i = 4，a[i] = a[4] = -3</code>，而这个-3是我们要寻找的一个元素<br>那么，<code>MAXN - a[i] = 10 - (-3) = 7</code><br>而<code>met[7]</code>已经被标记为<code>true</code>，所以<code>ans</code>增1<br>最终，这里只需要进行n次循环，就能覆盖所有的情况喵</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">100000</span>;  <span class="hljs-comment">// 此处 MAXN 是数组内元素的值域</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> a[])</span> </span>&#123;<br>    <span class="hljs-type">bool</span> met[MAXN * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>];  <span class="hljs-comment">// 创建一个能装下 [-MAXN, MAXN] 的桶</span><br>    <span class="hljs-built_in">memset</span>(met, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(met));<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (met[MAXN - a[i]]) ++ans;  <span class="hljs-comment">// 如果桶内有想要的元素，答案加一</span><br>        met[MAXN + a[i]] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 无论如何，都要把当前元素放进桶里</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>有一个由按钮组成的矩阵，其中每行有6个按钮，共5行。每个按钮的位置上有一盏灯。当按下一个按钮后，该按钮以及周围位置(上边、下边、左边、右边)的灯都会改变一次。即，如果灯原来是点亮的，就会被熄灭；如果灯原来是熄灭的，则会被点亮。在矩阵角上的按钮改变3盏灯的状态；在矩阵边上的按钮改变4盏灯的状态；其他的按钮改变5盏灯的状态。请你写一个程序，确定需要按下哪些按钮，恰好使得所有的灯都熄灭。</p>          </div><p>一开始看到题目，想要表示一个5x6的矩阵，我们就要定义一个二维数组了</p><div class="note note-primary">            <p>这里玩花活用容器会慢</p>          </div><p>如果我们把所有可能的状态表示出来的话，就有$2^{30}$种可能，这样的开销太大了<br>我们的目标是给所有的灯都熄灭，所以我们发现：按下一个按钮，它正上面的灯会改变，当前行的情况可以先忽略让下一行去处理，而仅仅注意当前行每个按钮上面的灯的状态，按这个按钮去控制它，可以引入“串行”的思想。<br>第一行的状态，就对应了下面行操作的唯一一种情况，每一行的操作都是：尽力熄灭上一行的灯。<br>当到达最后一行时，如果有当前行无论如何操作都不能熄灭的情况，那这次第一行的状态就是不合法的。</p><p>还可以发现，在边&#x2F;角上的按钮，操作范围也是周围四个灯，但是因为触及边界，所以只能操作界内的灯，如果按照5x6矩阵来表示，将会很麻烦，需要判断是否处于边界并做出相应更改。<br>为了简化这一过程，就在每个边外加入一行，使其变为7x8矩阵，这样忽略在界外的元素就好，不用去做特殊的处理了。</p><p>一个灯在被影响两次后，就会回到一开始的状态，这和一位二进制加法相似。所以，我们只需要表示“按下”这一动作为1，让两个“按下”作用的灯的“状态”相加，并将状态在二进制加法中表示，只考虑末尾一位就可。所以我们把这些1在十进制中相加再模除2，就是在二进制中表示的最后一位。</p><p>我们最后把最后一行的所有灯周围直接影响到它的所有操作都加一遍，看看它是不是0。如果它是1，这次的第一行<code>operate1st[]</code>是不可行的，就去到<code>while (!operate(operate1st))</code>进行更换，直到所有的情况都尝试一次……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> row = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> col = <span class="hljs-number">6</span>;<br><br><span class="hljs-comment">// 状态矩阵（包含边界）</span><br><span class="hljs-type">int</span> states[row<span class="hljs-number">+2</span>][col<span class="hljs-number">+2</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-comment">// 操作矩阵（包含边界）</span><br><span class="hljs-type">int</span> operations[row<span class="hljs-number">+2</span>][col<span class="hljs-number">+2</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据第一行操作计算整个操作矩阵</span><br><span class="hljs-comment"> * 返回最后一行是否满足条件</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operate</span><span class="hljs-params">(<span class="hljs-type">int</span> operate1st[])</span> </span>&#123;<br>    <span class="hljs-comment">// 设置第一行操作</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; col; j++) &#123;<br>        operations[<span class="hljs-number">1</span>][j<span class="hljs-number">+1</span>] = operate1st[j];<br>    &#125;<br><br>    <span class="hljs-comment">// 计算2~5行的操作</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; row; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= col; j++) &#123;<br>            operations[i<span class="hljs-number">+1</span>][j] = (operations[i][j] + operations[i<span class="hljs-number">-1</span>][j] + <br>                                 operations[i][j<span class="hljs-number">-1</span>] + operations[i][j<span class="hljs-number">+1</span>] + <br>                                 states[i][j]) % <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查最后一行是否满足条件</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= col; j++) &#123;<br>        <span class="hljs-type">int</span> check = (states[row][j] + operations[row][j<span class="hljs-number">-1</span>] + <br>                    operations[row][j] + operations[row][j<span class="hljs-number">+1</span>] + <br>                    operations[row<span class="hljs-number">-1</span>][j]) % <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (check == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= row; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= col; j++) &#123;<br>            cin &gt;&gt; states[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> operate1st[col] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 第一行操作序列</span><br><br>    <span class="hljs-comment">// 枚举所有可能的第一行操作组合 (2^6=64种)</span><br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">operate</span>(operate1st)) &#123;<br>        <span class="hljs-comment">// 二进制递增：类似二进制计数器</span><br>        operate1st[<span class="hljs-number">0</span>]++;<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (operate1st[index] &gt; <span class="hljs-number">1</span> &amp;&amp; index &lt; col - <span class="hljs-number">1</span>) &#123;<br>            operate1st[index] = <span class="hljs-number">0</span>;<br>            index++;<br>            operate1st[index]++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 输出结果矩阵 (5x6)</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= row; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= col; j++) &#123;<br>            cout &lt;&lt; operations[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>让Vim变得好看、顺手一些</title>
    <link href="/2025/06/05/vim-configure/"/>
    <url>/2025/06/05/vim-configure/</url>
    
    <content type="html"><![CDATA[<p>进行了YCM + Airline的配置</p><span id="more"></span><p><a href="https://github.com/zlicdt/vim-configure">Github repo link</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我有从Arch Linux &amp; Hyprland用回来macOS。<br>这边的预装Vim过于老旧，还没有vimrc，导致它是一个没有缩进、没有语法高亮，类似Debian系Vim的vi模式。<br>我在Arch那边有好好配置Vim，所以要对macOS这边也进行同步了，但是这边就会比Linux上繁琐一些，也是没办法的……<br><img src="/../img/vim-configure/screenshot.png"></p><h2 id="插件管理器-Vundle"><a href="#插件管理器-Vundle" class="headerlink" title="插件管理器 Vundle"></a>插件管理器 Vundle</h2><p><a href="https://github.com/VundleVim/Vundle.vim">Project Repo link</a><br>我们需要使用Vundle来安装插件，所以先</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim<br></code></pre></td></tr></table></figure><p>然后把如下的内容加入<code>~/.vimrc</code>中</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">set</span> nocompatible              <span class="hljs-comment">&quot; be iMproved, required</span><br><span class="hljs-keyword">filetype</span> off                  <span class="hljs-comment">&quot; required</span><br><br><span class="hljs-comment">&quot; set the runtime path to include Vundle and initialize</span><br><span class="hljs-keyword">set</span> rtp+=~/.<span class="hljs-keyword">vim</span>/bundle/Vundle.<span class="hljs-keyword">vim</span><br><span class="hljs-keyword">call</span> vundle#begin()<br><br><span class="hljs-comment">&quot; let Vundle manage Vundle, required</span><br>Plugin <span class="hljs-string">&#x27;VundleVim/Vundle.vim&#x27;</span><br><br><span class="hljs-comment">&quot; All of your Plugins must be added before the following line</span><br><span class="hljs-keyword">call</span> vundle#end()            <span class="hljs-comment">&quot; required</span><br><span class="hljs-keyword">filetype</span> plugin <span class="hljs-built_in">indent</span> <span class="hljs-keyword">on</span>    <span class="hljs-comment">&quot; required</span><br></code></pre></td></tr></table></figure><p>这里不要直接复制原仓库的README！那里后边的内容都是示例<br>然后打开vim，输入<code>:PluginInstall</code>，Vundle就安装了</p><h2 id="自动补全-YouCompleteMe"><a href="#自动补全-YouCompleteMe" class="headerlink" title="自动补全 YouCompleteMe"></a>自动补全 YouCompleteMe</h2><p><a href="https://github.com/ycm-core/YouCompleteMe">Project Repo Link</a><br>你可能注意到，仓库README里写了YCM需要vim构建为有Python 3支持的，但是macOS随附的vim是不带的，所以要再装一个。<br>YCM的补全功能并非是用脚本实现的，也不是预编译的，所以需要自己构建，要求cmake和启用的语言支持的相关依赖。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install vim cmake<br></code></pre></td></tr></table></figure><p>之后可以安装YCM文件了，打开<code>~/.vimrc</code>，在<code>Plugin &#39;VundleVim/Vundle.vim&#39;</code>下方加入</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">Plugin <span class="hljs-string">&#x27;ycm-core/YouCompleteMe&#x27;</span><br></code></pre></td></tr></table></figure><p>之后退出vim，再启动，输入<code>:PluginInstall</code><br>现在可以构建YCM了，切到YCM的目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/.vim/bundle/YouCompleteMe<br></code></pre></td></tr></table></figure><p>YCM的构建脚本，语言支持参数通常都是<code>--xxx-completer</code>格式，详情参见原仓库的README，并按需求使用</p><h3 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h3><p>这样的话，大家已经在<code>xcode-select</code>那一步安装了足够的工具，现在Mac上有<code>clangd</code>来支持C family的语言补全了<br>按需启用功能，这是列表</p><ul><li>Rust <code>--rust-completer</code> require <code>rust-analyzer</code></li><li>C&#x2F;C++ <code>--clangd-completer</code> require <code>clangd</code></li><li>Go <code>--go-completer</code> require <code>golang</code></li><li>JS&#x2F;TS <code>--ts-completer</code> require <code>nodejs</code><br>etc..<br>之后加上相关参数，进行构建，比如启用C&#x2F;C++ Rust JS&#x2F;TS的</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./install.py --clangd-completer --rust-completer --ts-completer<br></code></pre></td></tr></table></figure><p>也可以直接全开，不过我没有试过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./install.py --all<br></code></pre></td></tr></table></figure><h2 id="下横栏-Airline"><a href="#下横栏-Airline" class="headerlink" title="下横栏 Airline"></a>下横栏 Airline</h2><p><a href="https://github.com/vim-airline/vim-airline">Project Repo Link</a><br>这是一个信息栏，可以显示当前模式、文件名、文件格式、编码、还有词数、位置等等<br>打开<code>~/.vimrc</code>，在<code>Plugin &#39;ycm-core/YouCompleteMe&#39;</code>下方加入</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">Plugin <span class="hljs-string">&#x27;vim-airline/vim-airline&#x27;</span><br>Plugin <span class="hljs-string">&#x27;vim-airline/vim-airline-themes&#x27;</span><br></code></pre></td></tr></table></figure><p>之后退出vim，再启动，输入<code>:PluginInstall</code>，这次是安装Airline和它的theme<br>Airline中的部分主题、模式，可能需要nerd字体才能正常显示。我是用的是Meslo Nerd，可以通过<code>brew install font-meslo-lg-nerd-font</code>来安装。</p><h2 id="Vim-后续设置"><a href="#Vim-后续设置" class="headerlink" title="Vim 后续设置"></a>Vim 后续设置</h2><p>我们统一一下主题，给vim的colorscheme换成catppuccin<br>打开<code>~/.vimrc</code>，在<code>Plugin &#39;vim-airline/vim-airline-themes&#39;</code>下方加入</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">Plugin <span class="hljs-string">&#x27;catppuccin/nvim&#x27;</span><br></code></pre></td></tr></table></figure><p>在这之后，因为macOS上的vimrc是空壳……所以我们只好自己开启一些功能</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-comment">&quot; Enable syntax highlighting</span><br><span class="hljs-keyword">syntax</span> <span class="hljs-keyword">on</span><br><span class="hljs-comment">&quot; Enable line number</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">number</span><br><span class="hljs-comment">&quot; Set shiftwidth and tab to 4 spaces</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">sw</span>=<span class="hljs-number">4</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">ts</span>=<span class="hljs-number">4</span><br><span class="hljs-comment">&quot; Let search jump to the first match when typing</span><br><span class="hljs-keyword">set</span> incsearch<br><span class="hljs-keyword">colorscheme</span> catppuccin<br><span class="hljs-keyword">let</span> <span class="hljs-variable">g:airline_theme</span>=<span class="hljs-string">&#x27;catppuccin&#x27;</span><br></code></pre></td></tr></table></figure><p>这样就配置完成了。</p><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>放假了，假期很长<br>这是我这一学期发的第一篇blog，总是感觉没什么写的<br>前几天折腾ZFS+Arch+Hyprland，好像有很多东西，但是却又感觉文本太长，也无法确实记录<br>最终只是一小部分，在Arch折腾完之后又回来macOS搞，最终得以记录<br>想找回之前的热情，尽量找回吧</p>]]></content>
    
    
    
    <tags>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂谈 - A1</title>
    <link href="/2025/02/13/A1/"/>
    <url>/2025/02/13/A1/</url>
    
    <content type="html"><![CDATA[<p>步进A1</p><span id="more"></span><h2 id="春-2025"><a href="#春-2025" class="headerlink" title="春@2025"></a>春@2025</h2><p>春天总是令人舒适呢……</p><p>上次感受到这样的春天已经是2023年了。</p><p>当时总是想到一些美好的东西，又和现实的做题生活形成鲜明对比了，这不好。</p><p>这里是几座玻璃高楼 下面是个平台</p><p>对了，这里有一棵樱花树</p><p>对了，我是14岁的女孩子吗？</p><p>这里的风好清澈，推着山上的风力发电机，为我们提供不竭的电力</p><p>哦对，这里是学校，我们设计的环形工程</p><p>周围全是粉色的树，我们忘记了是什么。楼顶有被称为高架桥的宽栈道吧，整体形成了弧形，我不知道是为什么设计，不过上面景色很美</p><p>不过不要从实用角度考虑了。</p><p>很宁静的去处。</p><p>我不是猫猫，我旁边的女孩子是猫猫，我们沉醉在这里了，不要回去上课</p><p>您问这台机器？</p><p>这是22版幻14呐～ 6900HS+6800S</p><p>这是什么时候的梦呢？</p><p>「汩余若将不及兮，恐年岁之不吾与。」我再也不能做这种梦了。我已经算是高龄了。</p><p>后来我急急急，我厌恶做题，我要复现它。用文字无法表达那种美好。<br><del>这是恐春症的由来，当然现在已经治好了</del></p><p>若是又想起什么，我还回来补上的</p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>我发现我现在很难有有营养的内容产出了。</p><p>有的东西我在实操时候有学习到，但是忘记或者懒得写blog，后来就完全忘记了是什么事</p><p>再加上现在的学业压力，更难去更新了</p><p>但是本来这只是作为blog使用的站，而且挂在github pages上，不用我花钱，所以无论怎样它将一直存在的。</p><h2 id="开服"><a href="#开服" class="headerlink" title="开服"></a>开服</h2><p>我刚有一篇RLCraft开服记录，原因都在里面写好了。</p><p>这个寒假，我一直在和朋友们探索mc服务器</p><p>用作服务器的机器是3700x 32G内存。</p><p>一开始，我开了服务器供涩图群群友玩，但是现在也不怎么活跃了</p><p>然后我又在这台机器上开了一个1.20.6的服务器，给我高中同学玩</p><p>结果他们网瘾少年，每天16h以上在线</p><p>我做转发用的aliyun ecs，网费太贵了，像 <del>抢钱一样</del></p><p>平均每天都要干掉差不多十块钱，这太贵了</p><p>所以换到了sakura frp，因为都是共享节点，所以我只写了供高中同学玩的端口的转发</p><p>涩图群服也莫名其妙就关掉了。</p><p>结果几天前，sakura frp突然更换域名，我的frpc config失效了，然而我同时也转发了ssh，所以我在家连不上宿舍里的服务器了</p><p>直到今天回到学校，局域网内ssh过去才改好</p><p>然后又配了SRV记录，给涩图群服拉起来，又往两个群里发了“服务器复活了！！”</p><h2 id="离散数学"><a href="#离散数学" class="headerlink" title="离散数学"></a>离散数学</h2><p>我不知道定义，也没有查过</p><p>只不过看一边叫离散数学一边叫离散结构</p><p>只看了MIT的网课，有proof以及真值表什么的，这应该是第一部分</p><p>后面我看有图有树的</p><p>MIT的课后面还要教什么算法，迷</p><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>也是这一学期要学的</p><p>我不知道是什么契机，反正我在20年时候学过一阵子</p><p>当时我在用openSUSE Leap， <del>精德</del></p><p>咏唱的public static void main(String[] args)我还记得</p><p>忘了当时什么精神状态，在konsole里面使用宋体，逆天</p><h2 id="2021"><a href="#2021" class="headerlink" title="2021(?)"></a>2021(?)</h2><p>2021左右</p><p>当时还在上初中，闲暇时期使用arch，在用一个3200U的本子</p><p>有时候听着Recondite的Waldluft，还有Black Russian这种有清晨氛围的Techno，用那个残破的Linux网易云（当时还不算残破）</p><p>用1080p的低分屏，网易云不能hidpi的问题还没发现</p><p>喜欢在周末下雨的清晨，折腾gentoo</p><p>“给我来一杯Java！”</p><p>开源世界是永恒的，Linux是永恒的，Ruby是永恒的，Java是永恒的，……</p><p>所以我当年积极进行各种软件考古，FreeDOS，BSD，以及CentOS 6……</p><p>然而到现在，我再也没有了当时的激情，开始遥遥落后</p>]]></content>
    
    
    
    <tags>
      
      <tag>Talk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录 RLCraft 服务器的安装</title>
    <link href="/2025/01/17/rlcraft-installation/"/>
    <url>/2025/01/17/rlcraft-installation/</url>
    
    <content type="html"><![CDATA[<p>最近厌倦了原版生存，于是切换到RLCraft</p><span id="more"></span><h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><p>这两个下载好预备着，因为后续不大可能有大更新，所以是直链</p><a class="btn" href="https://www.curseforge.com/minecraft/modpacks/rlcraft/files/4612990"  target="_blank">RLCraft Server Pack</a><a class="btn" href="https://maven.minecraftforge.net/net/minecraftforge/forge/1.12.2-14.23.5.2860/forge-1.12.2-14.23.5.2860-installer.jar"  target="_blank">Forge 1.12.2 直链</a><p>然后，因为1.21.2是一个古老的版本，不能使用比较新的JRE（经测试17已经不能成功启动，未测试11）</p><p>所以我们只得使用 Java 8，相信JAVA_HOME的切换对于本站的读者已经不是难事。</p><p>对于Arch Linux，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman -S jre8-openjdk<br><span class="hljs-built_in">sudo</span> archlinux-java <span class="hljs-built_in">set</span> java-8-openjdk/jre<br></code></pre></td></tr></table></figure><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>我们新建一个文件夹作为服务器的root directory，在这里我将其命名为<code>rlcraft</code></p><p>之后将Forge installer和RLCraft压缩包放入其中，再解压RLCraft的压缩包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">❯ <span class="hljs-built_in">ls</span><br> config                                                   optionsof.txt  <span class="hljs-string">&#x27;RLCraft Server Pack 1.12.2 - Release v2.9.3.zip&#x27;</span>   scripts<br> forge-1.12.2-14.23.5.2860-installer.jar                  options.txt    <span class="hljs-string">&#x27;RLCraft v2.9.1c Changelog.txt&#x27;</span>                     server.properties<br><span class="hljs-string">&#x27;FOR SERVERS ONLY - SET THESE IN SERVER.PROPERTIES.txt&#x27;</span>   resourcepacks  <span class="hljs-string">&#x27;RLCraft v2.9.3 + v2.9.2d Changelog.txt&#x27;</span>            structures<br> mods                                                     resources      <span class="hljs-string">&#x27;RLCraft v2.9 Changelog.txt&#x27;</span><br><br></code></pre></td></tr></table></figure><p>安装Forge</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -jar forge-1.12.2-14.23.5.2860-installer.jar --installServer<br></code></pre></td></tr></table></figure><p>因为大陆的网络可能不好，所以Headless服务器推荐V2rayA，archcn源已收录</p><h1 id="启动！"><a href="#启动！" class="headerlink" title="启动！"></a>启动！</h1><p>相信本站的读者都已经有过开原版服的经历了，对后续的内容一定轻车熟路</p><p>修改server.properties和eula.txt</p><p><code>java -jar forge-1.12.2-14.23.5.2860.jar nogui</code></p><p><del>享受游戏即可</del>不好玩，不要玩，关了</p>]]></content>
    
    
    
    <tags>
      
      <tag>Minecraft</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂谈 - A0</title>
    <link href="/2025/01/15/A0/"/>
    <url>/2025/01/15/A0/</url>
    
    <content type="html"><![CDATA[<p>步进A0</p><span id="more"></span><h2 id="近期blog问题"><a href="#近期blog问题" class="headerlink" title="近期blog问题"></a>近期blog问题</h2><p>我很长一段时间弃管了这个blog,大约是十月到十二月，这段时间要复习准备期末考试，UIC相比于别的学校平时分给的多，所以期末不会捞太多</p><p>直到考Foundation of C Programming前一天晚上，我要进行复习，想起了我之前转载过阮一峰老师的C语言教程，遂打开看</p><p>于是我意识到 <strong>我的站挂了。</strong></p><p>因为那天要复习，所以我没去管太多，认为可能是cloudflare抽风了，等考试之后去更新下配置，不幸考完试就忘掉了</p><p>之后就是军训，因为广东天气炎热所以UIC的军训是在冬天，温度大概和东北的十月份左右差不多</p><p>然后<del>我把军训逃了</del></p><p>1月2日军训，我29号就回家了</p><p>之后HCC的群友也发现了这个站挂了，我也有时间搞这个，所以我去看了下github pages页</p><p>DNS check failed,然后与TLS相关的错误也有</p><p>于是我重新配置了下cloudflare的解析，在阿里云那边把DNS改到了cloudflare的，结果无限重定向</p><p>后来发现，cloudflare到github pages是http,而用户到cloudflare是https,于是我关掉了github pages的Enforce https,问题就解决了</p><p>上线几天，我一次装archlinux时看到有个地方之前改了一半，混乱不堪，于是我又进行了修改</p><p>我将把修复内容与这篇杂谈一起推送，并且修改了一些UI颜色配置，更改了背景图（文文。新闻 ke-ta老师的作品）</p><h2 id="近期听的音乐"><a href="#近期听的音乐" class="headerlink" title="近期听的音乐"></a>近期听的音乐</h2><p>我开始怀旧了，怀念前几年了</p><p>整理一下网课的年份：2020和2022年</p><p>我是从20年春季开始听鼠曲的，至今Strobe听了2139次（网易云计数），现在写这篇blog时候我还在听</p><p>Strobe是两个曲子合一起的，看到油管上的扒谱分析，简直是天才之作，天才、汗水、匠心缺一不可</p><p>Intro分成四段，每个衔接配合的精妙程度，只能用浑然天成来说</p><p>Lead的音色是使用Strobe合成器捏出来的，这个合成器现在是第二代，当时还是类似TUI的形式，没有真正意义上的GUI，它会模拟实体合成器在高电平时候的音高偏移，制作出这种迷幻的效果</p><p>有人尝试使用别的合成器进行还原，还没有成功过的</p><p>旋律营造出一种温暖而又凶险的景色，宁静秋夜中望月的感觉，凉风静止，月光温暖但脆弱，照在地上银色的质感</p><p>后来的弦乐，是可以让我沉浸在宁静而又优美的氛围中</p><p>后面浑然天成的渐进，音色设计和混音都很精细，是鼠曲一贯的常态，中段的转调和drop前的synth是令我最惊奇的</p><p>后来听了很多鼠曲，我评价为具有超级魔力的，甚至能给我生成很多不应属于我的记忆</p><p>只记得2009年冬天，和几个野生技术人员，深夜在朝着什么方向走。夜空清澈，群星闪烁，绿光紫光蓝光这种</p><p>我喜欢鼠曲，因为总能找到和我精神状态相符的曲子，或者能从中感受到什么或者看到什么</p><p>我想尽数追随印象中2009年的状态，可当时我现实中才三岁</p><p>我整了个网易云歌单叫【非常好Deadmau5】收集这些，它们总能给我带来2009年到2013年左右的幻境</p><p>至于别的，在20年后期听Melodic Techno，推荐德国制作人Recondite, 光头大佬，很强</p><p>22年和20年大致差不多，听了Deadmau5没发的一些ID,比如之前的Hit Save和The hive</p><p>Hit Save是唯一有可能超越Strobe的曲子，而The Hive只是一个很早的也很短的Trance罢了，但是有那种很积极的感觉，现在的曲子所不具备的感觉</p><p>还有别的，不过最核心的说完了</p><h2 id="近期的状态"><a href="#近期的状态" class="headerlink" title="近期的状态"></a>近期的状态</h2><p>等待期末出分很紧张，不过还行，意料之外体育C-，看来是我逃体测的原因</p><p>提前回到了吉林，真是横着走，一身轻松了，学校那些焦躁的烂事和我无关了</p><p>物价还便宜，晚上到处去吃烤肉，几个想念馆子都吃一遍</p><p>还给驾照领了，最近被迫到哪去都开车来进行一个练车，不好的是晚上吃串不能喝酒了</p><p>带了一台7945HX+4060的R9000P回来，内存加到了32G</p><p>这个机器真的烫烫烫，7950X直接放本子里了</p><p>不过现在用arch,为了逃避逆天NVIDIA的驱动问题，使用 <del>核显直连</del></p><p>就是那个H55&#x2F;桌面zen4带的2CU小RDNA2,叫做Radeon 610M,不配有RX，是最弱的光追卡，不过可以正常睡眠&#x2F;唤醒</p><p>然后游戏使用prime-run开，这样可以跑在独显上，完美</p><h3 id="关于围棋"><a href="#关于围棋" class="headerlink" title="关于围棋"></a>关于围棋</h3><p><strong>我不会</strong></p><p>但是可以看到我的blog有一篇katago安装教程</p><p>小时候学过（6岁），定到10级，跑路，全忘</p><p>2022年时候重新审视，发现竟然如此高深莫测，黑白子在天圆地方无数变化，古今中外群星闪耀</p><p>被美到，重新开始跟柯洁的皮套人学，后来又跑路</p><p>当时拿katago到野狐上去下的，现在想起来太耻辱了，这不就是竞技游戏开挂么</p><p>现在继续跟雪糕进行一个学，希望这次不会半途跑路</p><hr><p>先说这么多吧</p>]]></content>
    
    
    
    <tags>
      
      <tag>Talk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 初步教程</title>
    <link href="/2024/08/21/git-guide/"/>
    <url>/2024/08/21/git-guide/</url>
    
    <content type="html"><![CDATA[<p>时光机，启动！</p><span id="more"></span><h2 id="版本控制系统（VCS）概述"><a href="#版本控制系统（VCS）概述" class="headerlink" title="版本控制系统（VCS）概述"></a>版本控制系统（VCS）概述</h2><h3 id="一个小情景"><a href="#一个小情景" class="headerlink" title="一个小情景"></a>一个小情景</h3><p>设想一下，如果你写了一个程序，它会有一个甚至多个源代码文件：<br><img src="/../img/git-guide/%E6%88%AA%E5%B1%8F2024-08-21%2015.57.47.png"><br>在这之后，你把它发布了（比如交作业）。<br>但是老师看完后，发现缺了功能，让你再进行修改；<br>你改完，又将它交上去了，但是老的功能又出了bug。<br>你很无奈，准备<strong>把它改回去，再在其基础上进行修改。</strong></p><p>这时候，你发现自己的<strong>第一版源代码被覆盖掉了！！</strong><br>然后你忘记了原来是怎样写的，遂PDF并重写。。</p><p>你发现，如果在第一版文件写成后<strong>将其存档，记为一个版本</strong>，这样就不会发生这种事了。<br>你可以在第二版被驳回后，返回到第一版并继续修改。<br>当然Git的功能远不止这些。</p><h3 id="VCS概念"><a href="#VCS概念" class="headerlink" title="VCS概念"></a>VCS概念</h3><div class="note note-info">            <p>有时候，一个程序同时存有两个以上的版本有其必要性，例如：发布版本中程序错误已经被修正，但没有加入新功能；而开发版本则有新的功能正在开发、也有新的错误待解决，于是便需要同时维护两个不同的版本。</p><p>此外，为了找出只存在于某一特定版本中的程序错误、或找出程序错误出现的版本，开发人员也必须通过比对不同版本的源代码以找出问题的位置。</p>          </div><p>我们可以使用版本控制器来：</p><ul><li>对一个目录中的内容创建不同版本</li><li>创建不同的时间线（分支）</li><li>切换到任意版本&#x2F;分支</li><li>比较各个版本中文件的差异</li></ul><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>我们要讲的Git，就是软件版本控制器中最著名的一个，也是应用最广的一个。<br>它由Linus Torvalds（Linux kernel项目创始人、主力开发者）使用C语言写成。<br>它负责管理了从Linux kernel v2.6至今的代码。<br>它是分布式的，意味着我们可以从其他机器获取更新版本的代码以及把我们的代码传输至其他机器上。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先要知道你使用的是什么平台。<br>各个平台的安装方式都是不同的。</p><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ol><li>Debian&#x2F;Ubuntu:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt update<br><span class="hljs-built_in">sudo</span> apt install git<br><span class="hljs-comment"># 然后看提示，按Y键、回车</span><br></code></pre></td></tr></table></figure><ol start="2"><li>RHEL&#x2F;Rocky Linux&#x2F;Alma Linux&#x2F;CentOS&#x2F;Fedora</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> dnf up<br><span class="hljs-built_in">sudo</span> dnf <span class="hljs-keyword">in</span> git<br><span class="hljs-comment"># 如果无法正常运行，可能是版本太老，请使用以下命令</span><br><span class="hljs-built_in">sudo</span> yum update<br><span class="hljs-built_in">sudo</span> yum install git<br></code></pre></td></tr></table></figure><ol start="3"><li>Arch Linux&#x2F;Manjaro</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman -Sy<br><span class="hljs-built_in">sudo</span> pacman -S git<br><span class="hljs-comment"># 回车</span><br></code></pre></td></tr></table></figure><ol start="4"><li>openSUSE&#x2F;SLE</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> zypper up<br><span class="hljs-built_in">sudo</span> zypper <span class="hljs-keyword">in</span> git<br></code></pre></td></tr></table></figure><ol start="5"><li>Gentoo Linux</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> emerge -a dev-vcs/git<br></code></pre></td></tr></table></figure><p>之后执行<code>git --version</code>：<br>如果有以下输出，安装就完成了：<br><img src="/../img/git-guide/%E6%88%AA%E5%B1%8F2024-08-21%2016.24.34.png"></p><h3 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h3><p>当然这需要新的macOS版本；<br>如果你还在用Catalina，请务必更新。</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">xcode-select --install<br></code></pre></td></tr></table></figure><p>这样，执行：<code>git --version</code><br><img src="/../img/git-guide/%E6%88%AA%E5%B1%8F2024-08-21%2016.41.31.png"><br>就对了。</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><ol><li>如果是Windows 11并且使用了魔法，那么你大概是可以使用<code>winget</code>的。这是很方便的。<br>按<code>Win + R</code>输入<code>powershell</code>，</li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">winget install --id Git.Git -e --source winget<br></code></pre></td></tr></table></figure><p>即可。</p><ol start="2"><li>如果不幸的事，你不喜欢更新，在使用老掉牙的1803版Windows 10，或者不能使用魔法：<br>从 <a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a> 下载适应你OS的版本。<br><img src="/../img/git-guide/%E6%88%AA%E5%B1%8F2024-08-21%2016.52.01.png"><br>一般人下载第二个就可，之后一路无脑Next。</li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>你新建了一个文件夹，你将在里面放置你要管理的文件（或者已经放置了）<br>如何让Git管理它呢？使用下面命令即可让Git接管它。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br></code></pre></td></tr></table></figure><p><img src="/../img/git-guide/%E6%88%AA%E5%B1%8F2024-08-21%2017.04.03.png"><br>现在，目录下多了一个.git文件夹，它就是负责存放Git的配置文件以及相关版本数据的。</p><h3 id="添加文件到仓库"><a href="#添加文件到仓库" class="headerlink" title="添加文件到仓库"></a>添加文件到仓库</h3><p>我们现在添加一个文件<code>test</code>进去，它的内容是：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">This is a test file.<br>Now, its version is:<br>    1<br></code></pre></td></tr></table></figure><p>记住现在它的版本是1。<br>如果你在使用一些“花里胡哨”的shell插件，比如omz，你会发现：<br><img src="/../img/git-guide/%E6%88%AA%E5%B1%8F2024-08-21%2017.10.01.png"><br>Git发现有一个文件被更改了。<br>这时候它还没有把这个文件记录在案，我们需要这样<strong>把一个文件加入仓库</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p><code>test</code>文件就被加入仓库了。<br>如果那你想把目录下的<strong>全部文件加入仓库</strong>，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br></code></pre></td></tr></table></figure><p>这样全部文件都会加进来。</p><h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><p>好的，你的这份作业已经写好，正准备交给老师。<br>现在我们需要把这堆文件记录成一个版本，也就是<strong>提交</strong>动作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;Version 1！加入test文件&quot;</span><br></code></pre></td></tr></table></figure><p>后面的<code>-m</code>参数是必加不可的，它是用来描述这个版本大概是做了什么的。<br>这两个引号，必须是英文的。<br>当然随便写命令也可以执行成功，但是不建议这么做。<br>因为到后面你可能看不懂这个版本是干什么的。</p><p>这样这个版本就被存储了下来。</p><h3 id="修改与回档（版本回退）"><a href="#修改与回档（版本回退）" class="headerlink" title="修改与回档（版本回退）"></a>修改与回档（版本回退）</h3><p>不幸，老师不认可你这份作业。你需要改进它，于是你修改<code>test</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sed -i <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-string">&#x27;s/1/2/g&#x27;</span> <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>这个属于sed替换文本，看不懂无视就好。</p><p>现在<code>test</code>文件已经是第二版了！<br><img src="/../img/git-guide/%E6%88%AA%E5%B1%8F2024-08-21%2017.33.31.png"><br>现在我们可以看到，我们的文件内容中的“1”变成了“2”，同时Git也发现了这个文件更改。<br>好了，我们再重复上一步提交。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit -m <span class="hljs-string">&quot;Version 2！修改test文件&quot;</span><br></code></pre></td></tr></table></figure><p>老师看了一下，原来他的不认可是来自于一个拼写错误：it’s &#x3D;&gt; its，并非不满意那个版本号。<br>看来并不需要修改版本号，只需要修改拼写错误就行。</p><div class="note note-info">            <p>有同学会觉得这是小题大做了，我只修改个版本号为什么要用Git回退，直接改一下不就行了么？</p><p>我这里只是在演示功能。如果你写一些大的工程，很多地方的语句&amp;调用函数等可能经过比较大程度的修改甚至覆盖。<br>这样做可以完全回到原来的状态。</p>          </div><p>Git用HEAD表示当前的版本。前一个版本就是HEAD^，前两个版本就是HEAD^^。<br>往前100个版本可以写100个^，但是这肯定是不易数的，所以可以写成HEAD~100。</p><p>我们往前退一个版本，而且要回到前一个版本的已提交状态，所以我们：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard HEAD^<br></code></pre></td></tr></table></figure><p>现在查看下<code>test</code>文件的内容：<br><img src="/../img/git-guide/%E6%88%AA%E5%B1%8F2024-08-21%2017.53.55.png"><br><code>--hard</code>参数会回退到上个版本的已提交状态，<code>--soft</code>会回退到上个版本的未提交状态，<code>--mixed</code>会回退到上个版本已添加但未提交的状态。</p><p>然后你修改文件再提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sed -i <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-string">&quot;s/its/it&#x27;s/g&quot;</span> <span class="hljs-built_in">test</span><br>git add .<br>git commit -m <span class="hljs-string">&quot;Commit 2: fix spell issue.&quot;</span><br></code></pre></td></tr></table></figure><p>你可能觉得写<code>HEAD^</code>的方法过于笨拙，当然还有一种方法可以解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p><img src="/../img/git-guide/%E6%88%AA%E5%B1%8F2024-08-21%2018.17.22.png"><br>当然在这里，你的commit id和我的不会一样。<br>之后，如果你想回到哪个版本，就：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard 版本commit <span class="hljs-built_in">id</span><br></code></pre></td></tr></table></figure><p>这里的commit id不需要写全，当然写一两个字母也不行。主要是让Git分辨出来特定版本，又不与别的版本混淆就行。<br>比如前6个字符大概就可。</p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>你可能听说过一些平台，比如 Github, Gitlab等，这些都是Git远程仓库平台。<br>那么，如何使用这些远程仓库呢？</p><h3 id="Clone（克隆）"><a href="#Clone（克隆）" class="headerlink" title="Clone（克隆）"></a>Clone（克隆）</h3><p>没错，命令就是<code>git clone</code>。<br>后面接链接与本地目标目录。<br>比如，从Github克隆Linux内核的仓库到当前用户主目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/torvalds/linux.git ~/linux<br></code></pre></td></tr></table></figure><p>这后面名字可以自己起，但是建议维持原名，最多只在其基础上加点东西。<br>现在，远程的目录就被1:1复刻到你这里来了。</p><h3 id="Pull（拉取）"><a href="#Pull（拉取）" class="headerlink" title="Pull（拉取）"></a>Pull（拉取）</h3><p>过了一段时间，Linux内核源码的仓库更新了，而你的仓库还是旧版本，这时候该如何同步？<br>切换到仓库目录下，运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull<br></code></pre></td></tr></table></figure><p>这样仓库就会更新了。</p><h3 id="Push（推送）"><a href="#Push（推送）" class="headerlink" title="Push（推送）"></a>Push（推送）</h3><p>显然，Linux内核源码仓库是很严格的，只有官方人员才能提交代码。<br>所以，我们自己创建一个Github仓库用于演示：<br><img src="/../img/git-guide/%E6%88%AA%E5%B1%8F2024-08-21%2018.32.54.png"><br>创建之后，是这样的：<br><img src="/../img/git-guide/%E6%88%AA%E5%B1%8F2024-08-21%2018.33.21.png"><br>你看它下面都写出来了，如何给本地仓库设置远程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin https://github.com/zlicdt/Test.git<br>git branch -M main<br>git push -u origin main<br></code></pre></td></tr></table></figure><p>这样，远程仓库这辈子就有了。<br><img src="/../img/git-guide/%E6%88%AA%E5%B1%8F2024-08-21%2018.36.04.png"><br>（请忽略我用老邮箱进行提交导致的头像变动</p><h3 id="另请注意"><a href="#另请注意" class="headerlink" title="另请注意"></a>另请注意</h3><p>Github应该是在很久以前（似乎是2020-2021年间）禁止了只使用用户名+邮箱进行的提交。<br>我们可能遇到相关提示，并且有一大堆很麻烦的操作。<br>表面上是为了安全，实际上却是安全了，但更多的是推自家的github-cli，它可以概括为让你在CLI登录Github账号，从而正常进行推送。<br>建议都装一个。</p><h2 id="更新中，敬请期待……"><a href="#更新中，敬请期待……" class="headerlink" title="更新中，敬请期待……"></a>更新中，敬请期待……</h2>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么选择 Mac</title>
    <link href="/2024/08/12/why-choose-mac/"/>
    <url>/2024/08/12/why-choose-mac/</url>
    
    <content type="html"><![CDATA[<p>优势、以及购买型号推荐</p><span id="more"></span><h2 id="先前提要"><a href="#先前提要" class="headerlink" title="先前提要"></a>先前提要</h2><p>在2020年前，Mac一直是属于价格高，核心硬件配置低的代表。只有屏幕和机身是不能骂的。<br>因为早在2012年，MacBook Pro就已经开始使用1440p（也就是我们常说的2K，2560x1440）的分辨率了。<br>显示色域也是早早达到了100% sRGB的标准。<br>同样的，机身使用当时极度少有的CNC加工铝合金，是成本最高的一档。</p><p>然而核心硬件的素质很是低下，经常采用低压15w平台的双核Intel Core i5&#x2F;i7，性能在当时面对采用H35标压的友商，差距是不能接受的。<br>内存全部为板载，更换需要把内存颗粒吹下来再焊上更大容量的颗粒。<br>只有到后期，高端的15寸MacBook Pro才会搭载Intel H45和AMD Radeon移动端独显，然而最高级的型号也只是RX 5600M（是HBM显存！！）</p><p>直到Apple Silicon发布了，M1惊艳全场，但仍有很多兼容性问题。<br>需要通过Rosetta 2转译运行。<br>但是运行原生二进制时，在当年的笔记本市场是大杀四方了。<br>大约是5800H~11800H的水准。<br>说剪视频很强，其实很多插件不能用，而且也只是在导出方面有专用单元罢了。</p><p>我也一直拒绝买Mac，认为那是高价低配的，买Mac的是冲着外观、系统、屏幕、触控板去的。<br>而我，一个使用过各种恶劣机器的，用Arch的折腾患者，这种机器不适合我的人设。</p><p>然后终于，我高中毕业，考进了CDS，要买一台新机器。</p><h2 id="我拥有的设备"><a href="#我拥有的设备" class="headerlink" title="我拥有的设备"></a>我拥有的设备</h2><ol><li>神舟战神 Z7-DA5NP<br> 模具：蓝天 V155<br> CPU：i5-12500H@睿频4.5GHz<br> GPU：RTX 3050 Laptop 4G（Micron）<br> 内存：三星8G DDR4 3200MHz x 2 &#x3D; 16G<br> 硬盘：自带的打码固态，PCIE3.0 512G，主控群联<br> 屏幕：自行更换的NE156QHM-NY2，2K 165Hz 100% sRGB<br> 系统：如今作为Minecraft Server，使用Debian 12<br> 双风扇四铜管，纯塑料机身，miniDP和HDMI口只能连1080p 120Hz&#x2F;2K 60Hz，单M.2，又一个3.5寸SATA盘位</li><li>台式机<br> 板子：MSI MAG MORTAR B550M MAX WIFI<br> CPU：R7-5700X<br> GPU：[MSI SUPRIM] NVIDIA GeForce RTX 3080 LHR 10G<br> 内存：铭瑄DDR4 3200MHz 16G x 2 &#x3D; 32G（颗粒Micron）<br> 硬盘1：梵想 S790 PCIE4.0 1TB（主控MAP1602+长存白片，通过丝印无法查到颗粒信息，232层）<br> 硬盘2：三星 PM9A1 PCIE4.0 1TB（插在3.0的口）<br> 散热器：酷妈 暴雪 T620S 双风扇6热管</li></ol><h2 id="我买的机器"><a href="#我买的机器" class="headerlink" title="我买的机器"></a>我买的机器</h2><p>MacBook Pro (16-inch, Nov 2023, Three Thunderbolt 4 ports)<br>译：<br>MacBook Pro (16英寸, 2023年11月, 三个雷雳4接口)<br>苹果的特立独行导致这个官方翻译叫“雷雳4”，是我们通常说的“雷电4”。</p><p>CPU: M3 Max 16 Cores(12P + 4E, max turbo freq: 4.05GHz)<br>GPU: M3 Max 40 Cores<br>RAM: 48G LPDDR5 板载<br>SSD: 1T 板载（速度近似PCIE4.0，连接被命名为Apple Fabric）</p><h2 id="外在"><a href="#外在" class="headerlink" title="外在"></a>外在</h2><ol><li><p>屏幕<br> <strong>当今量产型号最强的miniLED显示器</strong>，在这。</p><p> 分辨率3456x2234<br> 最大亮度1600nit（显示HDR内容时）<br> Display P3色域（色域容积&gt;sRGB）</p></li><li><p>外放<br> 这是不用多说的。<br> 参考蓝天X170.</p></li></ol><h2 id="内在"><a href="#内在" class="headerlink" title="内在"></a>内在</h2><p>这是我要重中之重提及的。</p><ol><li><p>包管理<br> Mac本来不存在包管理器，但是提及Mac上的包管理器，人们都会想到<strong>Homebrew</strong><br> <a href="https://brew.sh/">https://brew.sh/</a><br> 你会发现，包括字体在内，都是可以使用brew安装的。<br> 这里有大量包，包括原生macOS程序，其他平台（如GNU&#x2F;Linux的移植）以及.app格式的应用。<br> Linux平台的软件，对于一个CST人是很重要的。当然原生Linux更好。<br> 广度大于Homebrew的应该只有Arch Linux official + cn + AUR了吧（笑<br> （（Debian&#x2F;Ubuntu的官方源竟然没有<code>fastfetch</code>！</p><p> 反观隔壁Windows，来自Linux的移植软件属实<strong>稀缺无比</strong>。<br> WSL2也是访问Windows目录困难，所以你需要开VSCode+WSL Remote插件连WSL。<br> 如果你使用WSL开Linux GUI软件，莫名其妙的问题太多，并且本来这也只是个简陋功能。<br> 并且Windows这边的包管理器，都<strong>严重依赖软件本家的获取途径，并且依赖软件的GUI安装程序</strong>（很多软件不支持自动化安装）。</p></li><li><p>字体渲染<br> 依赖Mac常有的高分辨率，Mac通常都是高ppi的。<br> 以至于macOS的字体渲染都能说“清晰、重实”。</p><p> 反观Windows那边，字体渲染是一个常常被提起的诟病。<br> Windows的字体渲染得发虚，以至于很多人都用<strong>MacType</strong>这个软件来模拟Mac的字体渲染。<br> 但是MacType在Windows 11中，不能应用在软件标题栏了。<br> 至此，让Windows认真渲染文字的方法只剩下开高缩放。</p><p> 但是谈到缩放这个方面，不知你有没有注意过：<br> Windows建议的缩放倍数是根据大部分软件GUI占用最小像素数时不挤到任务栏下面的缩放倍数。<br> 然而在这个缩放倍数下，Windows会把文字渲染得很奇怪。<br> 比如使用微软雅黑字体时，“大”这个字，你会发现中间这一行很细，很难看。<br> 然而，在你使用2K屏时，把缩放拉到200%以上，你会发现这个问题解决了。<br> 但是在200%的缩放下，很多软件都无法正常显示了，它的底边会挤到任务栏下面。<br> 你甚至没法把窗口缩小，因为鼠标不能移动到任务栏下面。<br> <strong>所以你需要换4K及以上的屏，并把缩放拉到200%以上。</strong></p><p> 这是个奇妙的问题，奇妙到头大。然而它在Mac上是不会存在的，任何字都显示得很好。</p></li><li><p>字体配置<br> 首先普及：<strong>字体回落</strong>这一概念</p> <div class="note note-info">            <p>“字体回落”用于指定一系列的字体选项，当首选字体不可用时，浏览器会按照这个列表尝试加载下一个可用的字体。这样，即使首选字体在用户的设备上不可用，页面仍然可以使用备选字体显示文本，从而保持设计的一致性。</p>          </div><p> 举个例子：<br> 你在使用VSCode撰写Markdown文章，就像我现在这样。<br> 然而你注意到，现在编辑器内显示的中文文字很丑，它大概是叫做“宋体”的字体。<br> 但是英文确是你在settings.json里设置的Cascadia Code等宽字体。</p><p> 这就涉及到了字体回落。<br> 在字体没有提供中文文字时，Windows会把中文文字以宋体显示。<br> 没错，这里的默认回落字体是宋体。</p><p> 如果你想使用好看一点的微软雅黑，你需要这么做：</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;editor.fontFamily&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Cascadia Code, &#x27;微软雅黑&#x27;&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p> 然而在Mac上，这个问题是不存在的。<br> 当你使用中文locale时，默认的回落字体是苹方。</p></li><li><p>Unix环境<br> 这个问题和上面的包管理器问题是同源的。<br> Mac上有大量的移植软件，几乎所有开发工具都有Mac版本。</p><p> 很多脚本，都默认你使用类Unix环境，它们使用bash或zsh。<br> 一旦到了Windows，它们是废的。<br> WSL2本质上是Hyper-V开的虚拟机，这样你的机器就又跑了个CPU分配相同、内存是总内存一半的虚拟机。<br> 而MSYS2 cygwin之类的项目，只是模拟环境，速度极慢不说，还有很多bug。</p><p> PowerShell固然是很强大的，但是它过于反直觉，而且命令记忆相当困难，速度也慢。<br> 现在有<code>oh-my-posh</code>项目，可以装上PowerShell版的OMZ，但是相比OMZ，功能差了很多。</p></li></ol><h2 id="型号推荐"><a href="#型号推荐" class="headerlink" title="型号推荐"></a>型号推荐</h2><p>我推所有16寸的机器。<br>不过根据现在考虑，还是等M4 Pro的？<br>M4 ST性能自然不用说，MT性能已经和M2 Max接近了。<br>只怕M4 Pro打平M3 Max残血「10P+4E」（笑</p><h2 id="结"><a href="#结" class="headerlink" title="结"></a>结</h2><p>总习惯把macOS和Windows比。<br>现在用Windows台式机，只打游戏和跑图。</p><p>其实Linux才是真正的强者，什么都可以自由配置&#x2F;选择。<br>缺点可能是没有公司做和自家发行版完美结合的硬件，<br>而且桌面环境相比macOS过于简陋了（笑</p><p>推荐Arch Linux，可以到我的blog翻安装教程。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Talk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GPG 入门教程</title>
    <link href="/2024/01/18/gpg-tourial/"/>
    <url>/2024/01/18/gpg-tourial/</url>
    
    <content type="html"><![CDATA[<p>如何使用这个最流行、最好用的加密工具之一</p><span id="more"></span><h1 id="什么是GPG"><a href="#什么是GPG" class="headerlink" title="什么是GPG"></a>什么是GPG</h1><p>1991年，程序员 <a href="https://en.wikipedia.org/wiki/Phil_Zimmermann">Phil Zimmermann</a> 为了避开政府监视，开发了加密软件PGP。这个软件非常好用，迅速流传开来，成了许多程序员的必备工具。但是，它是商业软件，不能自由使用。所以，自由软件基金会决定，开发一个 PGP 的替代品，取名为 GnuPG，也就是 GPG</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>GPG有两种安装方式。可以<a href="http://www.gnupg.org/download/index.en.html">下载源码</a>，自己编译安装</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs zsh">./configure<br>make<br>make install<br></code></pre></td></tr></table></figure><p>也可以安装编译好的二进制包</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs zsh">pacman -S gnupg <span class="hljs-comment"># Arch Linux</span><br>apt install gnupg <span class="hljs-comment"># Debian 系</span><br>dnf <span class="hljs-keyword">in</span> gnupg <span class="hljs-comment"># RH 系</span><br>zypper <span class="hljs-keyword">in</span> gnupg <span class="hljs-comment"># 蜥蜴系</span><br></code></pre></td></tr></table></figure><h1 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h1><p>安装成功后，使用gen-ken参数生成自己的密钥</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">gpg --gen-key<br></code></pre></td></tr></table></figure><p>会输出</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">gpg (GnuPG) 2.4.3; Copyright (C) 2023 g10 Code GmbH<br>This is free software: you are free to change and redistribute it.<br>There is NO WARRANTY, to the extent permitted by law.<br><br>注意：使用 “gpg --full-generate-key” 以获得一个全功能的密钥生成对话框。<br><br>GnuPG 需要构建用户标识以辨认您的密钥。<br><br>真实姓名：<br></code></pre></td></tr></table></figure><p>这里需要按照问题填，填了回车，后按<code>O</code>确定</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs text">gpg (GnuPG) 2.4.3; Copyright (C) 2023 g10 Code GmbH<br>This is free software: you are free to change and redistribute it.<br>There is NO WARRANTY, to the extent permitted by law.<br><br>注意：使用 “gpg --full-generate-key” 以获得一个全功能的密钥生成对话框。<br><br>GnuPG 需要构建用户标识以辨认您的密钥。<br><br>真实姓名： zlicdt<br>电子邮件地址： xkicdt@163.com<br>您选定了此用户标识：<br>    “zlicdt &lt;xkicdt@163.com&gt;”<br><br>更改姓名（N）、注释（C）、电子邮件地址（E）或确定（O）/退出（Q）？<br></code></pre></td></tr></table></figure><p>然后它会让你“输入密码以保护您的新密钥”，<strong>这个密码最好填8位以上的</strong>，否则会</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">┌─────────────────────────────────────────────────────────────────────────────────────────┐<br>│ 警告：您输入了一个不安全的密码                                                               │<br>│                                                                                         │<br>│ A passphrase should be at least 8 characters long.                                      │<br>│                                                                                         │<br>│ &lt;无论如何都使用这个&gt;                                           &lt;输入新的密码&gt;                │<br>└─────────────────────────────────────────────────────────────────────────────────────────┘<br></code></pre></td></tr></table></figure><p>然后，它会</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">我们需要生成大量的随机字节。在质数生成期间做些其他操作（敲打键盘<br>、移动鼠标、读写硬盘之类的）将会是一个不错的主意；这会让随机数<br>发生器有更好的机会获得足够的熵。<br></code></pre></td></tr></table></figure><p>最终生成一个有效期为三年的 GPG key</p><h1 id="高级密钥生成"><a href="#高级密钥生成" class="headerlink" title="高级密钥生成"></a>高级密钥生成</h1><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">gpg --full-gen-key<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">gpg (GnuPG) 2.4.3; Copyright (C) 2023 g10 Code GmbH<br>This is free software: you are free to change and redistribute it.<br>There is NO WARRANTY, to the extent permitted by law.<br><br>请选择您要使用的密钥类型：<br>   (1) RSA 和 RSA<br>   (2) DSA 和 Elgamal<br>   (3) DSA（仅用于签名）<br>   (4) RSA（仅用于签名）<br>   (9) ECC（签名和加密） *默认*<br>  (10) ECC（仅用于签名）<br> （14）卡中现有密钥<br>您的选择是？<br></code></pre></td></tr></table></figure><p>这里建议直接选择默认的 ECC</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs text">请选择您想要使用的椭圆曲线：<br>   (1) Curve 25519 *默认*<br>   (4) NIST P-384<br>   (6) Brainpool P-256<br>您的选择是？<br>请设定这个密钥的有效期限。<br>         0 = 密钥永不过期<br>      &lt;n&gt;  = 密钥在 n 天后过期<br>      &lt;n&gt;w = 密钥在 n 周后过期<br>      &lt;n&gt;m = 密钥在 n 月后过期<br>      &lt;n&gt;y = 密钥在 n 年后过期<br>密钥的有效期限是？(0)<br>密钥永远不会过期<br>这些内容正确吗？ (y/N) y<br><br>GnuPG 需要构建用户标识以辨认您的密钥。<br><br>真实姓名：<br></code></pre></td></tr></table></figure><p>后来就和上部分一样了</p><h1 id="密钥管理"><a href="#密钥管理" class="headerlink" title="密钥管理"></a>密钥管理</h1><h2 id="列出密钥"><a href="#列出密钥" class="headerlink" title="列出密钥"></a>列出密钥</h2><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">gpg --list-keys<br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">pub   ed25519 2024-01-18 [SC] [有效至：2027-01-17]<br>      F624D1B3CC89BF5760DCF150A30A42DE01DE13B5<br>uid             [ 绝对 ] zlicdt &lt;xkicdt@163.com&gt;<br>sub   cv25519 2024-01-18 [E] [有效至：2027-01-17]<br></code></pre></td></tr></table></figure><p>第一行显示公钥特征（算法，Hash字符串和生成时间），第二行显示”用户ID”，第三行显示私钥特征</p><p>如果你要从密钥列表中删除某个密钥，可以使用delete-key参数：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">gpg --delete-key [用户ID]<br></code></pre></td></tr></table></figure><p><strong>不过这样的话，如果它对应一个私钥的话，需要先删掉私钥，它会给出命令提示</strong></p><h2 id="输出密钥"><a href="#输出密钥" class="headerlink" title="输出密钥"></a>输出密钥</h2><p>公钥文件以二进制形式储存，armor 参数可以将其转换为 ASCII 码显示</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">gpg --armor --<span class="hljs-built_in">export</span> [用户ID]<br></code></pre></td></tr></table></figure><p>类似地，export-secret-keys 参数可以转换私钥</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">gpg --armor --export-secret-keys<br></code></pre></td></tr></table></figure><h2 id="上传公钥"><a href="#上传公钥" class="headerlink" title="上传公钥"></a>上传公钥</h2><p>公钥服务器是网络上专门储存用户公钥的服务器。send-keys 参数可以将公钥上传到服务器</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">gpg --send-keys [用户ID] --keyserver https://keys.openpgp.org<br></code></pre></td></tr></table></figure><p>使用上面的命令，你的公钥就被传到了服务器 subkeys.pgp.net，然后通过交换机制，所有的公钥服务器最终都会包含你的公钥</p><p>由于公钥服务器没有检查机制，任何人都可以用你的名义上传公钥，所以没有办法保证服务器上的公钥的可靠性。通常，你可以在网站上公布一个公钥指纹，让其他人核对下载到的公钥是否为真。fingerprint 参数生成公钥指纹</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">gpg --fingerprint [用户ID]<br></code></pre></td></tr></table></figure><h2 id="导入密钥"><a href="#导入密钥" class="headerlink" title="导入密钥"></a>导入密钥</h2><p>除了生成自己的密钥，还需要将他人的公钥或者你的其他密钥输入系统。这时可以使用 import 参数</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">gpg --import [密钥文件]<br></code></pre></td></tr></table></figure><p>为了获得他人的公钥，可以让对方直接发给你，或者到公钥服务器上寻找</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">gpg --keyserver https://keys.openpgp.org --search-keys [用户ID]<br></code></pre></td></tr></table></figure><h1 id="加密和解密"><a href="#加密和解密" class="headerlink" title="加密和解密"></a>加密和解密</h1><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">gpg --recipient [用户ID] --encrypt demo.txt<br></code></pre></td></tr></table></figure><p>这会在当前目录下生成一个 demo.txt.gpg 文件，cat 其中的内容发现是已经经过加密的，不可读取</p><p>这时候传输文件就是安全的</p><h2 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h2><p>对方收到加密文件以后，就用自己的私钥解密</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">gpg --decrypt demo.txt.gpg<br></code></pre></td></tr></table></figure><p>此时它会在 terminal 里直接输出文件内容<br>GPG 允许省略 decrypt 参数，直接可以达到相同的效果</p><h1 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h1><h2 id="对文件签名"><a href="#对文件签名" class="headerlink" title="对文件签名"></a>对文件签名</h2><p>有时我们不需要加密文件，只需要对文件签名，表示这个文件确实是我本人发出的。<br>sign 参数用来签名</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">gpg --sign demo.txt<br></code></pre></td></tr></table></figure><p>运行上面的命令后，当前目录下生成 demo.txt.gpg 文件，这就是签名后的文件。这个文件默认采用二进制储存，如果想生成 ASCII 码的签名文件，可以使用 clearsign 参数</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">gpg --clearsign demo.txt<br></code></pre></td></tr></table></figure><p>运行上面的命令后 ，当前目录下生成demo.txt.asc文件，后缀名asc表示该文件是ASCII码形式的，现在这个可读了</p><p>如果想生成单独的签名文件，与文件内容分开存放，可以使用 detach-sign 参数</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">gpg --detach-sign demo.txt<br></code></pre></td></tr></table></figure><p>运行上面的命令后，当前目录下生成一个单独的签名文件 demo.txt.sig。该文件是二进制形式的，如果想采用 ASCII 码形式，要加上 armor 参数</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">gpg --armor --detach-sign demo.txt<br></code></pre></td></tr></table></figure><h2 id="签名-加密"><a href="#签名-加密" class="headerlink" title="签名+加密"></a>签名+加密</h2><p>上一节的参数，都是只签名不加密。如果想同时签名和加密，可以使用下面的命令</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">gpg --local-user [发信者ID] --recipient [接收者ID] --armor --sign --encrypt demo.txt<br></code></pre></td></tr></table></figure><p>local-user 参数指定用发信者的私钥签名，recipient 参数指定用接收者的公钥加密，armor 参数表示采用 ASCII 码形式显示，sign 参数表示需要签名，encrypt 参数表示指定源文件</p><h2 id="验证签名"><a href="#验证签名" class="headerlink" title="验证签名"></a>验证签名</h2><p>我们收到别人签名后的文件，需要用对方的公钥验证签名是否为真。verify 参数用来验证</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">gpg --verify demo.txt.asc demo.txt<br></code></pre></td></tr></table></figure><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ol><li>Paul Heinlein, <a href="http://www.madboa.com/geek/gpg-quickstart/">GPG Quick Start</a></li><li>Ubuntu help, <a href="https://help.ubuntu.com/community/GnuPrivacyGuardHowto">GnuPrivacyGuardHowto</a></li><li>KNL, <a href="http://www.bitflop.com/document/129">GnuPG Tutorial</a></li><li>Alan Eliasen. <a href="http://futureboy.us/pgp.html">GPG Tutorial</a></li><li><a href="http://www.gnupg.org/gph/en/manual.html">The GNU Privacy Handbook</a></li><li><a href="https://www.ruanyifeng.com/blog/2013/07/gpg.html">GPG入门教程 - 阮一峰的网络日志</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>GPG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo Fluid 主题安装 Gitalk</title>
    <link href="/2024/01/05/hexo-fluid-with-gitalk/"/>
    <url>/2024/01/05/hexo-fluid-with-gitalk/</url>
    
    <content type="html"><![CDATA[<p>给 Hexo 加个评论插件 Gitalk</p><span id="more"></span><h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><p>首先，看到这里的话，你应该已经在 Github Pages 上部署好 Hexo + Fluid 了罢<br>咱看 fluid 的配置文件，里面写好了<strong>评论插件：Options: utterances | disqus | gitalk | valine…</strong><br>咱要选的就是这个 gitalk，基于 Github issue，无论是作者还是读者，有个 Github 账号就能用</p><h2 id="建立用于存储评论的仓库"><a href="#建立用于存储评论的仓库" class="headerlink" title="建立用于存储评论的仓库"></a>建立用于存储评论的仓库</h2><p>因为是基于 issue，所以要开一个公共 github 存储库（已存在或创建一个新的 github 存储库）来开这些 issue<br><img src="/../img/hexo-fluid-with-gitalk/1.png"><br>就像这个一样，是空的，只要是 public 的就行</p><h2 id="创建-GitHub-Application"><a href="#创建-GitHub-Application" class="headerlink" title="创建 GitHub Application"></a>创建 GitHub Application</h2><a class="btn" href="https://github.com/settings/applications/new"  target="_blank">点这申请</a><p>然后这个像这样填就行<br><img src="/../img/hexo-fluid-with-gitalk/2.png"><br>记得<code>xxxxx</code>要改啊</p><h2 id="把主体用-npm-装上"><a href="#把主体用-npm-装上" class="headerlink" title="把主体用 npm 装上"></a>把主体用 npm 装上</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm i <span class="hljs-literal">--save</span> gitalk<br></code></pre></td></tr></table></figure><h1 id="嵌入"><a href="#嵌入" class="headerlink" title="嵌入"></a>嵌入</h1><p>然后回到<code>_config.yml</code><br>把</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-params">post:</span><br>    <span class="hljs-params">comments:</span><br>        <span class="hljs-params">enable:</span> <span class="hljs-literal">true</span><br>        <span class="hljs-params">type:</span> gitalk<br><br><span class="hljs-params">gitalk:</span><br>    <span class="hljs-params">clientID:</span> <br>    <span class="hljs-params">clentSecret:</span> <br>    <span class="hljs-params">repo:</span> gitalk-comments<br>    <span class="hljs-params">owner:</span> xxxxx<br>    <span class="hljs-params">admin:</span> [&#x27;xxxxx&#x27;]<br>    <span class="hljs-comment"># 都改成自己的，前两个就在申请完 Github Application 的页面，repo 按照你的评论存储仓库填，owner 和 admin 都改成你自己的用户名</span><br></code></pre></td></tr></table></figure><p>然后重新<code>hexo d -g</code><br>这就完事了</p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何用 Electron 制作一个抽号的程序</title>
    <link href="/2023/01/01/random-makeing-note/"/>
    <url>/2023/01/01/random-makeing-note/</url>
    
    <content type="html"><![CDATA[<p>电子包写的随机抽号</p><span id="more"></span><a class="btn" href="https://github.com/acidec/random"  target="_blank">代码</a><h2 id="技术栈选择"><a href="#技术栈选择" class="headerlink" title="技术栈选择"></a>技术栈选择</h2><p>抽号机事给普通人用的，他们对于这些大概一窍不通，所以不能写纯 TUI 的。<br>要易用，有图形界面，像个正常软件一样，界面可以简单不能简陋。<br>我直接想到了电子包这个梗，简单易用出图形界面，会一点前端就行。<br><del>用电子包写软件，我们都有光明的未来</del></p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><p>首先你得有<code>nodejs</code>、可用的网络（别用残废的China Mainland局域网）、<code>git</code></p><a class="btn" href="https://nodejs.org/en"  target="_blank">nodejs</a><p>&amp;</p><a class="btn" href="https://mirrors.bfsu.edu.cn/github-release/git-for-windows/git/LatestRelease/"  target="_blank">git</a><h3 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git config <span class="hljs-literal">--global</span> user.name 名字 //可以随便填<br>git config <span class="hljs-literal">--global</span> user.email 邮箱 //要能用的，要是就看看代码也可以随便填<br>git config <span class="hljs-literal">--global</span> http.sslVerify false<br></code></pre></td></tr></table></figure><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">mkdir random &amp;&amp; <span class="hljs-built_in">cd</span> random<br>npm init<br></code></pre></td></tr></table></figure><p>然后他开始问问题，实话回答就行。</p><h3 id="启动脚本"><a href="#启动脚本" class="headerlink" title="启动脚本"></a>启动脚本</h3><p>最标准的，参考文档的启动脚本，创建一个<code>main.js</code>，填入以下内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> &#123; app, <span class="hljs-title class_">BrowserWindow</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;electron&#x27;</span>)<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">createWindow</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> win = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrowserWindow</span>(&#123;<br>    <span class="hljs-attr">width</span>: <span class="hljs-number">1600</span>,<br>    <span class="hljs-attr">height</span>: <span class="hljs-number">1000</span>,<br>    <span class="hljs-attr">title</span>:<span class="hljs-string">&quot;抽号机&quot;</span><br>  &#125;)<br><br>  win.<span class="hljs-title function_">loadFile</span>(<span class="hljs-string">&#x27;index.html&#x27;</span>)<br>&#125;<br><br>app.<span class="hljs-title function_">whenReady</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">createWindow</span>()<br>&#125;)<br><br>app.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;window-all-closed&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (process.<span class="hljs-property">platform</span> !== <span class="hljs-string">&#x27;darwin&#x27;</span>) app.<span class="hljs-title function_">quit</span>()<br>  &#125;)<br><br></code></pre></td></tr></table></figure><p>其意为启动一个1600x1200的窗口，标题为”抽号机”，渲染”index.html”</p><h3 id="渲染的HTML"><a href="#渲染的HTML" class="headerlink" title="渲染的HTML"></a>渲染的HTML</h3><p>名字在<code>main.js</code>里写了叫<code>index.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;css/bootstrap.css&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container-fluid&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container-fluid&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>这是什么？抽号机喵~<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hr</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border-top:1px dotted #ccc;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container-fluid&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>1/54，保留6号<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-info btn-lg&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;rollNumber();&quot;</span>&gt;</span>抽！<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container-fluid&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>结果：<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;result&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;script.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>班级有54个人，6号休学去写曲子了，把他留着。<br>引入了<code>BootStrap CSS</code>，去下载：</p><a class="btn" href="https://getbootstrap.com/docs/3.4/getting-started/"  target="_blank">BootStrap CSS</a><p>下载之后把三样东西都放到<code>random</code>文件夹下。<br><del>按钮变得好看起来</del></p><p>引入的外部js代码在<code>script.js</code>里。</p><h3 id="逻辑部分"><a href="#逻辑部分" class="headerlink" title="逻辑部分"></a>逻辑部分</h3><p>需要用代码实现预定范围的随机数生成，并将其返回显示。<br><code>index.html</code>里写了代码在<code>script.js</code>里。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">rollNumber</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-keyword">var</span> set = [];<br><span class="hljs-keyword">while</span>(set.<span class="hljs-property">length</span> &lt; <span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">var</span> r = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">53</span>) + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(set.<span class="hljs-title function_">indexOf</span>(r) === -<span class="hljs-number">1</span>) set.<span class="hljs-title function_">push</span>(r);<br>&#125;<br> <br><span class="hljs-title function_">displayResult</span>(set);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">displayResult</span>(<span class="hljs-params">set</span>)&#123;<br>set.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;, &quot;</span>);<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;result&#x27;</span>).<span class="hljs-property">innerHTML</span>=<span class="hljs-string">&quot;&lt;center&gt;&lt;h1 class=&#x27;text-primary&#x27;&gt;&quot;</span>+set+<span class="hljs-string">&quot;&lt;/h1&gt;&lt;/center&gt;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>从1-54号中抽一个并返回。</p><h2 id="跑"><a href="#跑" class="headerlink" title="跑"></a>跑</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm run <span class="hljs-built_in">start</span><br></code></pre></td></tr></table></figure><p>启动一个Electron窗口，就是这个。呐，跑起来了。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>这是我放在 Github 上的代码的目录结构。<br>建议在获取之后运行下面代码更新 npm 包</p><p><code>npx npm-check-updates -u</code></p><ul><li><p>.gitignore -&gt; 忽略一些构建生成和node modules，要不这几百M放Github上每次还得更新</p></li><li><p>forge.config.js -&gt; 打包工具的依赖</p></li><li><p>index.html -&gt; 网页</p></li><li><p>main.js -&gt; 启动脚本</p></li><li><p>package(-lock).json -&gt; npm的购物清单</p></li><li><p>script.js -&gt; JavaScript代码</p></li><li><p>namelist.json -&gt; new feature的名单，已打码（new feature暂时还未实现、、</p></li><li><p>css &amp; fonts &amp; js -&gt; Bootstrap CSS</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Electron</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KataGo 安装</title>
    <link href="/2022/12/15/katago/"/>
    <url>/2022/12/15/katago/</url>
    
    <content type="html"><![CDATA[<p>现在开源的最强围棋AI。elo大概13k+？</p><span id="more"></span><p>源代码可用。 <a href="https://github.com/lightvector/KataGo">Github link</a>.</p><h2 id="获取模型文件"><a href="#获取模型文件" class="headerlink" title="获取模型文件"></a>获取模型文件</h2><p>如果你有现代GPU（比如GCN1.0&#x2F;Volta往后的），我建议用 OpenCL 版本。核显也是能跑的。<br>没卡或者卡太老的话，用 Eigen 这个用 CPU 跑的版本。还有支持 AVX2 的，要求4代 Core 以后了。<br>CUDA 版本配置过于繁琐，而且必须要用N卡。<br>Windows:</p><a class="btn" href="https://github.com/lightvector/KataGo/releases/download/v1.14.0/katago-v1.14.0-opencl-windows-x64.zip"  target="_blank">openCL</a><p>&amp;&amp;</p><a class="btn" href="https://github.com/lightvector/KataGo/releases/download/v1.14.0/katago-v1.14.0-eigenavx2-windows-x64.zip"  target="_blank">Eigen AVX2</a><p>Linux:</p><a class="btn" href="https://github.com/lightvector/KataGo/releases/download/v1.14.0/katago-v1.14.0-opencl-linux-x64.zip"  target="_blank">openCL</a><p>&amp;&amp;</p><a class="btn" href="https://github.com/lightvector/KataGo/releases/download/v1.14.0/katago-v1.14.0-eigenavx2-linux-x64.zip"  target="_blank">Eigen AVX2</a><p><strong>把这些解压，一会要用</strong></p><h2 id="下-KaTrain"><a href="#下-KaTrain" class="headerlink" title="下 KaTrain"></a>下 KaTrain</h2><p>官方推荐的 KataGO GUI<br><img src="/../img/katago/1.png"></p><a class="btn" href="https://github.com/sanderland/katrain"  target="_blank">Github Link</a><p>三平台运行支持，但是</p><ul><li>官方没有 Linux 版，需要自己编译;</li><li>macOS 版本不支持 aarch64，要用 Rosetta 2 转译</li></ul><p>Windows:</p><a class="btn" href="https://github.com/sanderland/katrain/releases/download/v1.14.0/KaTrain.exe"  target="_blank">Download</a><p>解压然后运行 <code>KaTrain.exe</code> -&gt;<br><img src="/../img/katago/2.png"><br>打开菜单，选择 <code>General &amp; Engine Settings</code> -&gt;<br><img src="/../img/katago/3.png"><br>把模型路径放到<code>Path to KataGo executable</code>里.</p><h2 id="还有"><a href="#还有" class="headerlink" title="还有"></a>还有</h2><p><code>Maximum number of visits in analysis</code>越大，这个 AI 越强<br><img src="/../img/katago/4.png"></p>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Arch Linux 部署 Docker</title>
    <link href="/2022/11/29/archlinux-deploy-docker/"/>
    <url>/2022/11/29/archlinux-deploy-docker/</url>
    
    <content type="html"><![CDATA[<p>Docker，每个人都爱用……</p><span id="more"></span><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><ul><li>Arch Linux x86_64</li><li>大于2GB的RAM</li><li><code>root</code> 权限</li></ul><h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><ol><li>通过 <code>pacman</code> 安装 <code>docker</code> 软件包 -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> pacman -S docker<br></code></pre></td></tr></table></figure></li><li>在系统启动时自动启动 <code>docker</code> 守护程序 -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl <span class="hljs-built_in">enable</span> docker<br></code></pre></td></tr></table></figure></li><li>启动 <code>docker</code> 服务 -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl start docker<br></code></pre></td></tr></table></figure></li><li>加入能够使用 <code>docker</code> 守护程序的 <code>docker</code> 组 -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> usermod -G docker -a <span class="hljs-variable">$USER</span><br></code></pre></td></tr></table></figure></li><li>重新启动 <code>docker</code> 守护程序 -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl restart docker<br></code></pre></td></tr></table></figure></li></ol><hr><h2 id="后续部分"><a href="#后续部分" class="headerlink" title="后续部分"></a>后续部分</h2><ol><li>验证 <code>docker</code> 是否在运行 -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker version<br></code></pre></td></tr></table></figure></li><li>运行下面的命令将从 <code>dockerhub</code> 拉取并运行“Hello World” docker 容器 -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run archlinux<br></code></pre></td></tr></table></figure></li></ol><h2 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h2><ol><li>列出容器镜像 -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker image <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure> <img src="/../img/archlinux-deploy-docker/1.png"></li><li>列出所有容器 -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker container <span class="hljs-built_in">ls</span> -a<br></code></pre></td></tr></table></figure> <img src="/../img/archlinux-deploy-docker/2.png"></li><li>删除容器 -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker container <span class="hljs-built_in">rm</span> CONTAINER_NUMBER<br></code></pre></td></tr></table></figure> 对于这个 <code>CONTAINER_NUMBER</code>，也支持简写。</li><li>删除镜像 -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker image <span class="hljs-built_in">rm</span> -f IMAGE_NUMBER<br></code></pre></td></tr></table></figure> 这个 <code>IMAGE_NUMBER</code> 也支持简写。</li><li>启动 <code>Linux</code> 镜像并进行 <code>chroot</code> 进入 -&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it --name arch-test archlinux<br></code></pre></td></tr></table></figure> 这个命令是创建一个名为 <code>arch-test</code> 的容器，使用 <code>archlinux</code> 镜像作为模板并进行 <code>chroot</code> 进入。<br> <img src="/../img/archlinux-deploy-docker/3.png"><br> 使用 <code>docker ps</code> 命令查看容器信息。<br> <img src="/../img/archlinux-deploy-docker/4.png"></li></ol>]]></content>
    
    
    <categories>
      
      <category>Software</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何用 C++ 快速撑爆内存？</title>
    <link href="/2009/03/16/cpp-fast-out-of-memory/"/>
    <url>/2009/03/16/cpp-fast-out-of-memory/</url>
    
    <content type="html"><![CDATA[<p>节约内存，请（（</p><span id="more"></span><h2 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nya</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">int</span>* ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">nya</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>反复创建新指针并分配一些内存空间。由于 <code>while(true)</code> 是无限循环的，内存会很快被填满。</strong></p><div class="note note-warning">            <p>由于这个程序会占满内存，不会自动<code>kill</code>进程的操作系统（如Windows、macOS）将使用<code>swap</code>进行内存交换。<br>这可能导致大量写入磁盘！<br>在Windows上，它会导致系统不稳定甚至出现黑屏。在严重情况下，未保存的数据可能会丢失并且可能出现蓝屏。请确保在运行此程序之前已保存所有数据。</p>          </div><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p><strong>在现代Linux发行版（x86_64 Linux-6.6.1-ARCH），当内存满时，进程将被终止。<br>在macOS（arm64 Darwin 22.1.0）上，它将占用<code>swap</code>到最大限制，并且进程将不会被终止。<br>Windows（x86_64 NT10）不会终止进程，在内存满时屏幕会变黑。可能已经无法给核显驱动内存了罢（笑</strong></p>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
